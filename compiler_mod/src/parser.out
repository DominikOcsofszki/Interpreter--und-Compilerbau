Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> expression
Rule 1     expression -> - expression
Rule 2     expression -> expression + expression
Rule 3     expression -> expression - expression
Rule 4     expression -> expression * expression
Rule 5     expression -> expression / expression
Rule 6     expression -> STRUCT { sequence_struct }
Rule 7     expression_list -> expression , expression_list
Rule 8     expression_list -> expression
Rule 9     expression -> NUMBER
Rule 10    expression -> { sequence }
Rule 11    expression -> EXTEND ID { sequence_struct }
Rule 12    expression -> LOCAL ID ASSIGN expression IN expression
Rule 13    expression -> BOOL
Rule 14    expression -> IF expression THEN expression
Rule 15    expression -> IMPORT ID AS ID
Rule 16    dots -> .
Rule 17    dots -> . dots
Rule 18    sequence -> expression
Rule 19    sequence -> sequence ; expression
Rule 20    expression -> FLOAT
Rule 21    expression -> IF expression THEN expression ELSE expression
Rule 22    expression -> IMPORT ID
Rule 23    expression -> expression AND expression
Rule 24    expression -> expression EQ expression
Rule 25    expression -> expression = expression
Rule 26    expression -> expression > expression
Rule 27    expression -> expression < expression
Rule 28    expression -> expression GE expression
Rule 29    expression -> expression LE expression
Rule 30    expression -> expression NEQS expression
Rule 31    expression -> expression OR expression
Rule 32    expression -> expression NAND expression
Rule 33    expression -> LAMBDA_START LAMBDA expression
Rule 34    expression -> LAMBDA_START expression_list LAMBDA expression
Rule 35    expression -> STRING
Rule 36    expression -> ID dots ID
Rule 37    expression -> LOOP expression DO expression
Rule 38    expression -> CHAR
Rule 39    expression -> FOR expression ; expression ; expression DO expression
Rule 40    expression -> ID ( )
Rule 41    expression -> ID ( expression_list )
Rule 42    expression -> ID
Rule 43    expression -> ID dots ID ( )
Rule 44    expression -> ID dots ID ( expression_list )
Rule 45    expression -> WHILE expression DO expression
Rule 46    dots_in_struct_expression -> dots ID
Rule 47    expression -> [ expression_list ]
Rule 48    expression -> ID [ NUMBER ]
Rule 49    expression -> ( expression_list )
Rule 50    expression -> NOT expression
Rule 51    expression -> ID ASSIGN expression
Rule 52    expression -> dots ID ASSIGN expression
Rule 53    seq_assign_expression -> dots ID ASSIGN expression
Rule 54    sequence_struct -> seq_assign_expression
Rule 55    sequence_struct -> sequence_struct ; seq_assign_expression

Terminals, with rules where they appear

(                    : 40 41 43 44 49
)                    : 40 41 43 44 49
*                    : 4
+                    : 2
,                    : 7
-                    : 1 3
.                    : 16 17
/                    : 5
;                    : 19 39 39 55
<                    : 27
=                    : 25
>                    : 26
AND                  : 23
AS                   : 15
ASSIGN               : 12 51 52 53
BOOL                 : 13
CHAR                 : 38
DO                   : 37 39 45
ELSE                 : 21
EQ                   : 24
EXTEND               : 11
FLOAT                : 20
FOR                  : 39
GE                   : 28
ID                   : 11 12 15 15 22 36 36 40 41 42 43 43 44 44 46 48 51 52 53
IF                   : 14 21
IMPORT               : 15 22
IN                   : 12
LAMBDA               : 33 34
LAMBDA_START         : 33 34
LE                   : 29
LOCAL                : 12
LOOP                 : 37
NAND                 : 32
NEQS                 : 30
NOT                  : 50
NUMBER               : 9 48
OR                   : 31
STRING               : 35
STRUCT               : 6
THEN                 : 14 21
WHILE                : 45
[                    : 47 48
]                    : 47 48
error                : 
{                    : 6 10 11
}                    : 6 10 11

Nonterminals, with rules where they appear

dots                 : 17 36 43 44 46 52 53
dots_in_struct_expression : 
expression           : 1 2 2 3 3 4 4 5 5 7 8 12 12 14 14 18 19 21 21 21 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 34 37 37 39 39 39 39 45 45 50 51 52 53 0
expression_list      : 7 34 41 44 47 49
seq_assign_expression : 54 55
sequence             : 10 19
sequence_struct      : 6 11 55

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 1
    dots                           shift and go to state 15

state 1

    (0) S' -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 2

    (1) expression -> - . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 38
    dots                           shift and go to state 15

state 3

    (6) expression -> STRUCT . { sequence_struct }

    {               shift and go to state 39


state 4

    (10) expression -> { . sequence }
    (18) sequence -> . expression
    (19) sequence -> . sequence ; expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    sequence                       shift and go to state 40
    expression                     shift and go to state 41
    dots                           shift and go to state 15

state 5

    (9) expression -> NUMBER .

    +               reduce using rule 9 (expression -> NUMBER .)
    -               reduce using rule 9 (expression -> NUMBER .)
    *               reduce using rule 9 (expression -> NUMBER .)
    /               reduce using rule 9 (expression -> NUMBER .)
    AND             reduce using rule 9 (expression -> NUMBER .)
    EQ              reduce using rule 9 (expression -> NUMBER .)
    =               reduce using rule 9 (expression -> NUMBER .)
    >               reduce using rule 9 (expression -> NUMBER .)
    <               reduce using rule 9 (expression -> NUMBER .)
    GE              reduce using rule 9 (expression -> NUMBER .)
    LE              reduce using rule 9 (expression -> NUMBER .)
    NEQS            reduce using rule 9 (expression -> NUMBER .)
    OR              reduce using rule 9 (expression -> NUMBER .)
    NAND            reduce using rule 9 (expression -> NUMBER .)
    $end            reduce using rule 9 (expression -> NUMBER .)
    }               reduce using rule 9 (expression -> NUMBER .)
    ;               reduce using rule 9 (expression -> NUMBER .)
    THEN            reduce using rule 9 (expression -> NUMBER .)
    ,               reduce using rule 9 (expression -> NUMBER .)
    LAMBDA          reduce using rule 9 (expression -> NUMBER .)
    DO              reduce using rule 9 (expression -> NUMBER .)
    )               reduce using rule 9 (expression -> NUMBER .)
    ]               reduce using rule 9 (expression -> NUMBER .)
    IN              reduce using rule 9 (expression -> NUMBER .)
    ELSE            reduce using rule 9 (expression -> NUMBER .)


state 6

    (11) expression -> EXTEND . ID { sequence_struct }

    ID              shift and go to state 42


state 7

    (36) expression -> ID . dots ID
    (40) expression -> ID . ( )
    (41) expression -> ID . ( expression_list )
    (42) expression -> ID .
    (43) expression -> ID . dots ID ( )
    (44) expression -> ID . dots ID ( expression_list )
    (48) expression -> ID . [ NUMBER ]
    (51) expression -> ID . ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    (               shift and go to state 44
    +               reduce using rule 42 (expression -> ID .)
    -               reduce using rule 42 (expression -> ID .)
    *               reduce using rule 42 (expression -> ID .)
    /               reduce using rule 42 (expression -> ID .)
    AND             reduce using rule 42 (expression -> ID .)
    EQ              reduce using rule 42 (expression -> ID .)
    =               reduce using rule 42 (expression -> ID .)
    >               reduce using rule 42 (expression -> ID .)
    <               reduce using rule 42 (expression -> ID .)
    GE              reduce using rule 42 (expression -> ID .)
    LE              reduce using rule 42 (expression -> ID .)
    NEQS            reduce using rule 42 (expression -> ID .)
    OR              reduce using rule 42 (expression -> ID .)
    NAND            reduce using rule 42 (expression -> ID .)
    $end            reduce using rule 42 (expression -> ID .)
    }               reduce using rule 42 (expression -> ID .)
    ;               reduce using rule 42 (expression -> ID .)
    THEN            reduce using rule 42 (expression -> ID .)
    ,               reduce using rule 42 (expression -> ID .)
    LAMBDA          reduce using rule 42 (expression -> ID .)
    DO              reduce using rule 42 (expression -> ID .)
    )               reduce using rule 42 (expression -> ID .)
    ]               reduce using rule 42 (expression -> ID .)
    IN              reduce using rule 42 (expression -> ID .)
    ELSE            reduce using rule 42 (expression -> ID .)
    [               shift and go to state 45
    ASSIGN          shift and go to state 46
    .               shift and go to state 23

    dots                           shift and go to state 43

state 8

    (12) expression -> LOCAL . ID ASSIGN expression IN expression

    ID              shift and go to state 47


state 9

    (13) expression -> BOOL .

    +               reduce using rule 13 (expression -> BOOL .)
    -               reduce using rule 13 (expression -> BOOL .)
    *               reduce using rule 13 (expression -> BOOL .)
    /               reduce using rule 13 (expression -> BOOL .)
    AND             reduce using rule 13 (expression -> BOOL .)
    EQ              reduce using rule 13 (expression -> BOOL .)
    =               reduce using rule 13 (expression -> BOOL .)
    >               reduce using rule 13 (expression -> BOOL .)
    <               reduce using rule 13 (expression -> BOOL .)
    GE              reduce using rule 13 (expression -> BOOL .)
    LE              reduce using rule 13 (expression -> BOOL .)
    NEQS            reduce using rule 13 (expression -> BOOL .)
    OR              reduce using rule 13 (expression -> BOOL .)
    NAND            reduce using rule 13 (expression -> BOOL .)
    $end            reduce using rule 13 (expression -> BOOL .)
    }               reduce using rule 13 (expression -> BOOL .)
    ;               reduce using rule 13 (expression -> BOOL .)
    THEN            reduce using rule 13 (expression -> BOOL .)
    ,               reduce using rule 13 (expression -> BOOL .)
    LAMBDA          reduce using rule 13 (expression -> BOOL .)
    DO              reduce using rule 13 (expression -> BOOL .)
    )               reduce using rule 13 (expression -> BOOL .)
    ]               reduce using rule 13 (expression -> BOOL .)
    IN              reduce using rule 13 (expression -> BOOL .)
    ELSE            reduce using rule 13 (expression -> BOOL .)


state 10

    (14) expression -> IF . expression THEN expression
    (21) expression -> IF . expression THEN expression ELSE expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 48
    dots                           shift and go to state 15

state 11

    (15) expression -> IMPORT . ID AS ID
    (22) expression -> IMPORT . ID

    ID              shift and go to state 49


state 12

    (20) expression -> FLOAT .

    +               reduce using rule 20 (expression -> FLOAT .)
    -               reduce using rule 20 (expression -> FLOAT .)
    *               reduce using rule 20 (expression -> FLOAT .)
    /               reduce using rule 20 (expression -> FLOAT .)
    AND             reduce using rule 20 (expression -> FLOAT .)
    EQ              reduce using rule 20 (expression -> FLOAT .)
    =               reduce using rule 20 (expression -> FLOAT .)
    >               reduce using rule 20 (expression -> FLOAT .)
    <               reduce using rule 20 (expression -> FLOAT .)
    GE              reduce using rule 20 (expression -> FLOAT .)
    LE              reduce using rule 20 (expression -> FLOAT .)
    NEQS            reduce using rule 20 (expression -> FLOAT .)
    OR              reduce using rule 20 (expression -> FLOAT .)
    NAND            reduce using rule 20 (expression -> FLOAT .)
    $end            reduce using rule 20 (expression -> FLOAT .)
    }               reduce using rule 20 (expression -> FLOAT .)
    ;               reduce using rule 20 (expression -> FLOAT .)
    THEN            reduce using rule 20 (expression -> FLOAT .)
    ,               reduce using rule 20 (expression -> FLOAT .)
    LAMBDA          reduce using rule 20 (expression -> FLOAT .)
    DO              reduce using rule 20 (expression -> FLOAT .)
    )               reduce using rule 20 (expression -> FLOAT .)
    ]               reduce using rule 20 (expression -> FLOAT .)
    IN              reduce using rule 20 (expression -> FLOAT .)
    ELSE            reduce using rule 20 (expression -> FLOAT .)


state 13

    (33) expression -> LAMBDA_START . LAMBDA expression
    (34) expression -> LAMBDA_START . expression_list LAMBDA expression
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    LAMBDA          shift and go to state 50
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 51
    expression_list                shift and go to state 52
    dots                           shift and go to state 15

state 14

    (35) expression -> STRING .

    +               reduce using rule 35 (expression -> STRING .)
    -               reduce using rule 35 (expression -> STRING .)
    *               reduce using rule 35 (expression -> STRING .)
    /               reduce using rule 35 (expression -> STRING .)
    AND             reduce using rule 35 (expression -> STRING .)
    EQ              reduce using rule 35 (expression -> STRING .)
    =               reduce using rule 35 (expression -> STRING .)
    >               reduce using rule 35 (expression -> STRING .)
    <               reduce using rule 35 (expression -> STRING .)
    GE              reduce using rule 35 (expression -> STRING .)
    LE              reduce using rule 35 (expression -> STRING .)
    NEQS            reduce using rule 35 (expression -> STRING .)
    OR              reduce using rule 35 (expression -> STRING .)
    NAND            reduce using rule 35 (expression -> STRING .)
    $end            reduce using rule 35 (expression -> STRING .)
    }               reduce using rule 35 (expression -> STRING .)
    ;               reduce using rule 35 (expression -> STRING .)
    THEN            reduce using rule 35 (expression -> STRING .)
    ,               reduce using rule 35 (expression -> STRING .)
    LAMBDA          reduce using rule 35 (expression -> STRING .)
    DO              reduce using rule 35 (expression -> STRING .)
    )               reduce using rule 35 (expression -> STRING .)
    ]               reduce using rule 35 (expression -> STRING .)
    IN              reduce using rule 35 (expression -> STRING .)
    ELSE            reduce using rule 35 (expression -> STRING .)


state 15

    (52) expression -> dots . ID ASSIGN expression

    ID              shift and go to state 53


state 16

    (37) expression -> LOOP . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 54
    dots                           shift and go to state 15

state 17

    (38) expression -> CHAR .

    +               reduce using rule 38 (expression -> CHAR .)
    -               reduce using rule 38 (expression -> CHAR .)
    *               reduce using rule 38 (expression -> CHAR .)
    /               reduce using rule 38 (expression -> CHAR .)
    AND             reduce using rule 38 (expression -> CHAR .)
    EQ              reduce using rule 38 (expression -> CHAR .)
    =               reduce using rule 38 (expression -> CHAR .)
    >               reduce using rule 38 (expression -> CHAR .)
    <               reduce using rule 38 (expression -> CHAR .)
    GE              reduce using rule 38 (expression -> CHAR .)
    LE              reduce using rule 38 (expression -> CHAR .)
    NEQS            reduce using rule 38 (expression -> CHAR .)
    OR              reduce using rule 38 (expression -> CHAR .)
    NAND            reduce using rule 38 (expression -> CHAR .)
    $end            reduce using rule 38 (expression -> CHAR .)
    }               reduce using rule 38 (expression -> CHAR .)
    ;               reduce using rule 38 (expression -> CHAR .)
    THEN            reduce using rule 38 (expression -> CHAR .)
    ,               reduce using rule 38 (expression -> CHAR .)
    LAMBDA          reduce using rule 38 (expression -> CHAR .)
    DO              reduce using rule 38 (expression -> CHAR .)
    )               reduce using rule 38 (expression -> CHAR .)
    ]               reduce using rule 38 (expression -> CHAR .)
    IN              reduce using rule 38 (expression -> CHAR .)
    ELSE            reduce using rule 38 (expression -> CHAR .)


state 18

    (39) expression -> FOR . expression ; expression ; expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 55
    dots                           shift and go to state 15

state 19

    (49) expression -> ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression_list                shift and go to state 56
    expression                     shift and go to state 51
    dots                           shift and go to state 15

state 20

    (45) expression -> WHILE . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 57
    dots                           shift and go to state 15

state 21

    (47) expression -> [ . expression_list ]
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression_list                shift and go to state 58
    expression                     shift and go to state 51
    dots                           shift and go to state 15

state 22

    (50) expression -> NOT . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 59
    dots                           shift and go to state 15

state 23

    (16) dots -> . .
    (17) dots -> . . dots
    (16) dots -> . .
    (17) dots -> . . dots

    ID              reduce using rule 16 (dots -> . .)
    .               shift and go to state 23

    dots                           shift and go to state 60

state 24

    (2) expression -> expression + . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 61
    dots                           shift and go to state 15

state 25

    (3) expression -> expression - . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 62
    dots                           shift and go to state 15

state 26

    (4) expression -> expression * . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 63
    dots                           shift and go to state 15

state 27

    (5) expression -> expression / . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 64
    dots                           shift and go to state 15

state 28

    (23) expression -> expression AND . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 65
    dots                           shift and go to state 15

state 29

    (24) expression -> expression EQ . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 66
    dots                           shift and go to state 15

state 30

    (25) expression -> expression = . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 67
    dots                           shift and go to state 15

state 31

    (26) expression -> expression > . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 68
    dots                           shift and go to state 15

state 32

    (27) expression -> expression < . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 69
    dots                           shift and go to state 15

state 33

    (28) expression -> expression GE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 70
    dots                           shift and go to state 15

state 34

    (29) expression -> expression LE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 71
    dots                           shift and go to state 15

state 35

    (30) expression -> expression NEQS . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 72
    dots                           shift and go to state 15

state 36

    (31) expression -> expression OR . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 73
    dots                           shift and go to state 15

state 37

    (32) expression -> expression NAND . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 74
    dots                           shift and go to state 15

state 38

    (1) expression -> - expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 1 (expression -> - expression .)
    -               reduce using rule 1 (expression -> - expression .)
    *               reduce using rule 1 (expression -> - expression .)
    /               reduce using rule 1 (expression -> - expression .)
    AND             reduce using rule 1 (expression -> - expression .)
    EQ              reduce using rule 1 (expression -> - expression .)
    =               reduce using rule 1 (expression -> - expression .)
    >               reduce using rule 1 (expression -> - expression .)
    <               reduce using rule 1 (expression -> - expression .)
    GE              reduce using rule 1 (expression -> - expression .)
    LE              reduce using rule 1 (expression -> - expression .)
    NEQS            reduce using rule 1 (expression -> - expression .)
    OR              reduce using rule 1 (expression -> - expression .)
    NAND            reduce using rule 1 (expression -> - expression .)
    $end            reduce using rule 1 (expression -> - expression .)
    }               reduce using rule 1 (expression -> - expression .)
    ;               reduce using rule 1 (expression -> - expression .)
    THEN            reduce using rule 1 (expression -> - expression .)
    ,               reduce using rule 1 (expression -> - expression .)
    LAMBDA          reduce using rule 1 (expression -> - expression .)
    DO              reduce using rule 1 (expression -> - expression .)
    )               reduce using rule 1 (expression -> - expression .)
    ]               reduce using rule 1 (expression -> - expression .)
    IN              reduce using rule 1 (expression -> - expression .)
    ELSE            reduce using rule 1 (expression -> - expression .)

  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! /               [ shift and go to state 27 ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 39

    (6) expression -> STRUCT { . sequence_struct }
    (54) sequence_struct -> . seq_assign_expression
    (55) sequence_struct -> . sequence_struct ; seq_assign_expression
    (53) seq_assign_expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    .               shift and go to state 23

    sequence_struct                shift and go to state 75
    seq_assign_expression          shift and go to state 76
    dots                           shift and go to state 77

state 40

    (10) expression -> { sequence . }
    (19) sequence -> sequence . ; expression

    }               shift and go to state 78
    ;               shift and go to state 79


state 41

    (18) sequence -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 18 (sequence -> expression .)
    ;               reduce using rule 18 (sequence -> expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 42

    (11) expression -> EXTEND ID . { sequence_struct }

    {               shift and go to state 80


state 43

    (36) expression -> ID dots . ID
    (43) expression -> ID dots . ID ( )
    (44) expression -> ID dots . ID ( expression_list )

    ID              shift and go to state 81


state 44

    (40) expression -> ID ( . )
    (41) expression -> ID ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    )               shift and go to state 82
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression_list                shift and go to state 83
    expression                     shift and go to state 51
    dots                           shift and go to state 15

state 45

    (48) expression -> ID [ . NUMBER ]

    NUMBER          shift and go to state 84


state 46

    (51) expression -> ID ASSIGN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 85
    dots                           shift and go to state 15

state 47

    (12) expression -> LOCAL ID . ASSIGN expression IN expression

    ASSIGN          shift and go to state 86


state 48

    (14) expression -> IF expression . THEN expression
    (21) expression -> IF expression . THEN expression ELSE expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    THEN            shift and go to state 87
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 49

    (15) expression -> IMPORT ID . AS ID
    (22) expression -> IMPORT ID .

    AS              shift and go to state 88
    +               reduce using rule 22 (expression -> IMPORT ID .)
    -               reduce using rule 22 (expression -> IMPORT ID .)
    *               reduce using rule 22 (expression -> IMPORT ID .)
    /               reduce using rule 22 (expression -> IMPORT ID .)
    AND             reduce using rule 22 (expression -> IMPORT ID .)
    EQ              reduce using rule 22 (expression -> IMPORT ID .)
    =               reduce using rule 22 (expression -> IMPORT ID .)
    >               reduce using rule 22 (expression -> IMPORT ID .)
    <               reduce using rule 22 (expression -> IMPORT ID .)
    GE              reduce using rule 22 (expression -> IMPORT ID .)
    LE              reduce using rule 22 (expression -> IMPORT ID .)
    NEQS            reduce using rule 22 (expression -> IMPORT ID .)
    OR              reduce using rule 22 (expression -> IMPORT ID .)
    NAND            reduce using rule 22 (expression -> IMPORT ID .)
    $end            reduce using rule 22 (expression -> IMPORT ID .)
    }               reduce using rule 22 (expression -> IMPORT ID .)
    ;               reduce using rule 22 (expression -> IMPORT ID .)
    THEN            reduce using rule 22 (expression -> IMPORT ID .)
    ,               reduce using rule 22 (expression -> IMPORT ID .)
    LAMBDA          reduce using rule 22 (expression -> IMPORT ID .)
    DO              reduce using rule 22 (expression -> IMPORT ID .)
    )               reduce using rule 22 (expression -> IMPORT ID .)
    ]               reduce using rule 22 (expression -> IMPORT ID .)
    IN              reduce using rule 22 (expression -> IMPORT ID .)
    ELSE            reduce using rule 22 (expression -> IMPORT ID .)


state 50

    (33) expression -> LAMBDA_START LAMBDA . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 89
    dots                           shift and go to state 15

state 51

    (7) expression_list -> expression . , expression_list
    (8) expression_list -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ,               shift and go to state 90
    LAMBDA          reduce using rule 8 (expression_list -> expression .)
    )               reduce using rule 8 (expression_list -> expression .)
    ]               reduce using rule 8 (expression_list -> expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 52

    (34) expression -> LAMBDA_START expression_list . LAMBDA expression

    LAMBDA          shift and go to state 91


state 53

    (52) expression -> dots ID . ASSIGN expression

    ASSIGN          shift and go to state 92


state 54

    (37) expression -> LOOP expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 93
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 55

    (39) expression -> FOR expression . ; expression ; expression DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ;               shift and go to state 94
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 56

    (49) expression -> ( expression_list . )

    )               shift and go to state 95


state 57

    (45) expression -> WHILE expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 96
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 58

    (47) expression -> [ expression_list . ]

    ]               shift and go to state 97


state 59

    (50) expression -> NOT expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 50 (expression -> NOT expression .)
    -               reduce using rule 50 (expression -> NOT expression .)
    *               reduce using rule 50 (expression -> NOT expression .)
    /               reduce using rule 50 (expression -> NOT expression .)
    AND             reduce using rule 50 (expression -> NOT expression .)
    EQ              reduce using rule 50 (expression -> NOT expression .)
    =               reduce using rule 50 (expression -> NOT expression .)
    >               reduce using rule 50 (expression -> NOT expression .)
    <               reduce using rule 50 (expression -> NOT expression .)
    GE              reduce using rule 50 (expression -> NOT expression .)
    LE              reduce using rule 50 (expression -> NOT expression .)
    NEQS            reduce using rule 50 (expression -> NOT expression .)
    OR              reduce using rule 50 (expression -> NOT expression .)
    NAND            reduce using rule 50 (expression -> NOT expression .)
    $end            reduce using rule 50 (expression -> NOT expression .)
    }               reduce using rule 50 (expression -> NOT expression .)
    ;               reduce using rule 50 (expression -> NOT expression .)
    THEN            reduce using rule 50 (expression -> NOT expression .)
    ,               reduce using rule 50 (expression -> NOT expression .)
    LAMBDA          reduce using rule 50 (expression -> NOT expression .)
    DO              reduce using rule 50 (expression -> NOT expression .)
    )               reduce using rule 50 (expression -> NOT expression .)
    ]               reduce using rule 50 (expression -> NOT expression .)
    IN              reduce using rule 50 (expression -> NOT expression .)
    ELSE            reduce using rule 50 (expression -> NOT expression .)

  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! /               [ shift and go to state 27 ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 60

    (17) dots -> . dots .

    ID              reduce using rule 17 (dots -> . dots .)


state 61

    (2) expression -> expression + expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 2 (expression -> expression + expression .)
    -               reduce using rule 2 (expression -> expression + expression .)
    AND             reduce using rule 2 (expression -> expression + expression .)
    EQ              reduce using rule 2 (expression -> expression + expression .)
    =               reduce using rule 2 (expression -> expression + expression .)
    >               reduce using rule 2 (expression -> expression + expression .)
    <               reduce using rule 2 (expression -> expression + expression .)
    GE              reduce using rule 2 (expression -> expression + expression .)
    LE              reduce using rule 2 (expression -> expression + expression .)
    NEQS            reduce using rule 2 (expression -> expression + expression .)
    OR              reduce using rule 2 (expression -> expression + expression .)
    NAND            reduce using rule 2 (expression -> expression + expression .)
    $end            reduce using rule 2 (expression -> expression + expression .)
    }               reduce using rule 2 (expression -> expression + expression .)
    ;               reduce using rule 2 (expression -> expression + expression .)
    THEN            reduce using rule 2 (expression -> expression + expression .)
    ,               reduce using rule 2 (expression -> expression + expression .)
    LAMBDA          reduce using rule 2 (expression -> expression + expression .)
    DO              reduce using rule 2 (expression -> expression + expression .)
    )               reduce using rule 2 (expression -> expression + expression .)
    ]               reduce using rule 2 (expression -> expression + expression .)
    IN              reduce using rule 2 (expression -> expression + expression .)
    ELSE            reduce using rule 2 (expression -> expression + expression .)
    *               shift and go to state 26
    /               shift and go to state 27

  ! *               [ reduce using rule 2 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 2 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 62

    (3) expression -> expression - expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 3 (expression -> expression - expression .)
    -               reduce using rule 3 (expression -> expression - expression .)
    AND             reduce using rule 3 (expression -> expression - expression .)
    EQ              reduce using rule 3 (expression -> expression - expression .)
    =               reduce using rule 3 (expression -> expression - expression .)
    >               reduce using rule 3 (expression -> expression - expression .)
    <               reduce using rule 3 (expression -> expression - expression .)
    GE              reduce using rule 3 (expression -> expression - expression .)
    LE              reduce using rule 3 (expression -> expression - expression .)
    NEQS            reduce using rule 3 (expression -> expression - expression .)
    OR              reduce using rule 3 (expression -> expression - expression .)
    NAND            reduce using rule 3 (expression -> expression - expression .)
    $end            reduce using rule 3 (expression -> expression - expression .)
    }               reduce using rule 3 (expression -> expression - expression .)
    ;               reduce using rule 3 (expression -> expression - expression .)
    THEN            reduce using rule 3 (expression -> expression - expression .)
    ,               reduce using rule 3 (expression -> expression - expression .)
    LAMBDA          reduce using rule 3 (expression -> expression - expression .)
    DO              reduce using rule 3 (expression -> expression - expression .)
    )               reduce using rule 3 (expression -> expression - expression .)
    ]               reduce using rule 3 (expression -> expression - expression .)
    IN              reduce using rule 3 (expression -> expression - expression .)
    ELSE            reduce using rule 3 (expression -> expression - expression .)
    *               shift and go to state 26
    /               shift and go to state 27

  ! *               [ reduce using rule 3 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 3 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 63

    (4) expression -> expression * expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 4 (expression -> expression * expression .)
    -               reduce using rule 4 (expression -> expression * expression .)
    *               reduce using rule 4 (expression -> expression * expression .)
    /               reduce using rule 4 (expression -> expression * expression .)
    AND             reduce using rule 4 (expression -> expression * expression .)
    EQ              reduce using rule 4 (expression -> expression * expression .)
    =               reduce using rule 4 (expression -> expression * expression .)
    >               reduce using rule 4 (expression -> expression * expression .)
    <               reduce using rule 4 (expression -> expression * expression .)
    GE              reduce using rule 4 (expression -> expression * expression .)
    LE              reduce using rule 4 (expression -> expression * expression .)
    NEQS            reduce using rule 4 (expression -> expression * expression .)
    OR              reduce using rule 4 (expression -> expression * expression .)
    NAND            reduce using rule 4 (expression -> expression * expression .)
    $end            reduce using rule 4 (expression -> expression * expression .)
    }               reduce using rule 4 (expression -> expression * expression .)
    ;               reduce using rule 4 (expression -> expression * expression .)
    THEN            reduce using rule 4 (expression -> expression * expression .)
    ,               reduce using rule 4 (expression -> expression * expression .)
    LAMBDA          reduce using rule 4 (expression -> expression * expression .)
    DO              reduce using rule 4 (expression -> expression * expression .)
    )               reduce using rule 4 (expression -> expression * expression .)
    ]               reduce using rule 4 (expression -> expression * expression .)
    IN              reduce using rule 4 (expression -> expression * expression .)
    ELSE            reduce using rule 4 (expression -> expression * expression .)

  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! /               [ shift and go to state 27 ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 64

    (5) expression -> expression / expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 5 (expression -> expression / expression .)
    -               reduce using rule 5 (expression -> expression / expression .)
    *               reduce using rule 5 (expression -> expression / expression .)
    /               reduce using rule 5 (expression -> expression / expression .)
    AND             reduce using rule 5 (expression -> expression / expression .)
    EQ              reduce using rule 5 (expression -> expression / expression .)
    =               reduce using rule 5 (expression -> expression / expression .)
    >               reduce using rule 5 (expression -> expression / expression .)
    <               reduce using rule 5 (expression -> expression / expression .)
    GE              reduce using rule 5 (expression -> expression / expression .)
    LE              reduce using rule 5 (expression -> expression / expression .)
    NEQS            reduce using rule 5 (expression -> expression / expression .)
    OR              reduce using rule 5 (expression -> expression / expression .)
    NAND            reduce using rule 5 (expression -> expression / expression .)
    $end            reduce using rule 5 (expression -> expression / expression .)
    }               reduce using rule 5 (expression -> expression / expression .)
    ;               reduce using rule 5 (expression -> expression / expression .)
    THEN            reduce using rule 5 (expression -> expression / expression .)
    ,               reduce using rule 5 (expression -> expression / expression .)
    LAMBDA          reduce using rule 5 (expression -> expression / expression .)
    DO              reduce using rule 5 (expression -> expression / expression .)
    )               reduce using rule 5 (expression -> expression / expression .)
    ]               reduce using rule 5 (expression -> expression / expression .)
    IN              reduce using rule 5 (expression -> expression / expression .)
    ELSE            reduce using rule 5 (expression -> expression / expression .)

  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! /               [ shift and go to state 27 ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 65

    (23) expression -> expression AND expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 23 (expression -> expression AND expression .)
    OR              reduce using rule 23 (expression -> expression AND expression .)
    NAND            reduce using rule 23 (expression -> expression AND expression .)
    $end            reduce using rule 23 (expression -> expression AND expression .)
    }               reduce using rule 23 (expression -> expression AND expression .)
    ;               reduce using rule 23 (expression -> expression AND expression .)
    THEN            reduce using rule 23 (expression -> expression AND expression .)
    ,               reduce using rule 23 (expression -> expression AND expression .)
    LAMBDA          reduce using rule 23 (expression -> expression AND expression .)
    DO              reduce using rule 23 (expression -> expression AND expression .)
    )               reduce using rule 23 (expression -> expression AND expression .)
    ]               reduce using rule 23 (expression -> expression AND expression .)
    IN              reduce using rule 23 (expression -> expression AND expression .)
    ELSE            reduce using rule 23 (expression -> expression AND expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35

  ! +               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! =               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! NEQS            [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 66

    (24) expression -> expression EQ expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 24 (expression -> expression EQ expression .)
    EQ              reduce using rule 24 (expression -> expression EQ expression .)
    =               reduce using rule 24 (expression -> expression EQ expression .)
    NEQS            reduce using rule 24 (expression -> expression EQ expression .)
    OR              reduce using rule 24 (expression -> expression EQ expression .)
    NAND            reduce using rule 24 (expression -> expression EQ expression .)
    $end            reduce using rule 24 (expression -> expression EQ expression .)
    }               reduce using rule 24 (expression -> expression EQ expression .)
    ;               reduce using rule 24 (expression -> expression EQ expression .)
    THEN            reduce using rule 24 (expression -> expression EQ expression .)
    ,               reduce using rule 24 (expression -> expression EQ expression .)
    LAMBDA          reduce using rule 24 (expression -> expression EQ expression .)
    DO              reduce using rule 24 (expression -> expression EQ expression .)
    )               reduce using rule 24 (expression -> expression EQ expression .)
    ]               reduce using rule 24 (expression -> expression EQ expression .)
    IN              reduce using rule 24 (expression -> expression EQ expression .)
    ELSE            reduce using rule 24 (expression -> expression EQ expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34

  ! +               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! >               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! <               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 67

    (25) expression -> expression = expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 25 (expression -> expression = expression .)
    EQ              reduce using rule 25 (expression -> expression = expression .)
    =               reduce using rule 25 (expression -> expression = expression .)
    NEQS            reduce using rule 25 (expression -> expression = expression .)
    OR              reduce using rule 25 (expression -> expression = expression .)
    NAND            reduce using rule 25 (expression -> expression = expression .)
    $end            reduce using rule 25 (expression -> expression = expression .)
    }               reduce using rule 25 (expression -> expression = expression .)
    ;               reduce using rule 25 (expression -> expression = expression .)
    THEN            reduce using rule 25 (expression -> expression = expression .)
    ,               reduce using rule 25 (expression -> expression = expression .)
    LAMBDA          reduce using rule 25 (expression -> expression = expression .)
    DO              reduce using rule 25 (expression -> expression = expression .)
    )               reduce using rule 25 (expression -> expression = expression .)
    ]               reduce using rule 25 (expression -> expression = expression .)
    IN              reduce using rule 25 (expression -> expression = expression .)
    ELSE            reduce using rule 25 (expression -> expression = expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34

  ! +               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! -               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! *               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! /               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! >               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! <               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! GE              [ reduce using rule 25 (expression -> expression = expression .) ]
  ! LE              [ reduce using rule 25 (expression -> expression = expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 68

    (26) expression -> expression > expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 26 (expression -> expression > expression .)
    EQ              reduce using rule 26 (expression -> expression > expression .)
    =               reduce using rule 26 (expression -> expression > expression .)
    >               reduce using rule 26 (expression -> expression > expression .)
    <               reduce using rule 26 (expression -> expression > expression .)
    GE              reduce using rule 26 (expression -> expression > expression .)
    LE              reduce using rule 26 (expression -> expression > expression .)
    NEQS            reduce using rule 26 (expression -> expression > expression .)
    OR              reduce using rule 26 (expression -> expression > expression .)
    NAND            reduce using rule 26 (expression -> expression > expression .)
    $end            reduce using rule 26 (expression -> expression > expression .)
    }               reduce using rule 26 (expression -> expression > expression .)
    ;               reduce using rule 26 (expression -> expression > expression .)
    THEN            reduce using rule 26 (expression -> expression > expression .)
    ,               reduce using rule 26 (expression -> expression > expression .)
    LAMBDA          reduce using rule 26 (expression -> expression > expression .)
    DO              reduce using rule 26 (expression -> expression > expression .)
    )               reduce using rule 26 (expression -> expression > expression .)
    ]               reduce using rule 26 (expression -> expression > expression .)
    IN              reduce using rule 26 (expression -> expression > expression .)
    ELSE            reduce using rule 26 (expression -> expression > expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27

  ! +               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 69

    (27) expression -> expression < expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 27 (expression -> expression < expression .)
    EQ              reduce using rule 27 (expression -> expression < expression .)
    =               reduce using rule 27 (expression -> expression < expression .)
    >               reduce using rule 27 (expression -> expression < expression .)
    <               reduce using rule 27 (expression -> expression < expression .)
    GE              reduce using rule 27 (expression -> expression < expression .)
    LE              reduce using rule 27 (expression -> expression < expression .)
    NEQS            reduce using rule 27 (expression -> expression < expression .)
    OR              reduce using rule 27 (expression -> expression < expression .)
    NAND            reduce using rule 27 (expression -> expression < expression .)
    $end            reduce using rule 27 (expression -> expression < expression .)
    }               reduce using rule 27 (expression -> expression < expression .)
    ;               reduce using rule 27 (expression -> expression < expression .)
    THEN            reduce using rule 27 (expression -> expression < expression .)
    ,               reduce using rule 27 (expression -> expression < expression .)
    LAMBDA          reduce using rule 27 (expression -> expression < expression .)
    DO              reduce using rule 27 (expression -> expression < expression .)
    )               reduce using rule 27 (expression -> expression < expression .)
    ]               reduce using rule 27 (expression -> expression < expression .)
    IN              reduce using rule 27 (expression -> expression < expression .)
    ELSE            reduce using rule 27 (expression -> expression < expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27

  ! +               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 70

    (28) expression -> expression GE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 28 (expression -> expression GE expression .)
    EQ              reduce using rule 28 (expression -> expression GE expression .)
    =               reduce using rule 28 (expression -> expression GE expression .)
    >               reduce using rule 28 (expression -> expression GE expression .)
    <               reduce using rule 28 (expression -> expression GE expression .)
    GE              reduce using rule 28 (expression -> expression GE expression .)
    LE              reduce using rule 28 (expression -> expression GE expression .)
    NEQS            reduce using rule 28 (expression -> expression GE expression .)
    OR              reduce using rule 28 (expression -> expression GE expression .)
    NAND            reduce using rule 28 (expression -> expression GE expression .)
    $end            reduce using rule 28 (expression -> expression GE expression .)
    }               reduce using rule 28 (expression -> expression GE expression .)
    ;               reduce using rule 28 (expression -> expression GE expression .)
    THEN            reduce using rule 28 (expression -> expression GE expression .)
    ,               reduce using rule 28 (expression -> expression GE expression .)
    LAMBDA          reduce using rule 28 (expression -> expression GE expression .)
    DO              reduce using rule 28 (expression -> expression GE expression .)
    )               reduce using rule 28 (expression -> expression GE expression .)
    ]               reduce using rule 28 (expression -> expression GE expression .)
    IN              reduce using rule 28 (expression -> expression GE expression .)
    ELSE            reduce using rule 28 (expression -> expression GE expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27

  ! +               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 71

    (29) expression -> expression LE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 29 (expression -> expression LE expression .)
    EQ              reduce using rule 29 (expression -> expression LE expression .)
    =               reduce using rule 29 (expression -> expression LE expression .)
    >               reduce using rule 29 (expression -> expression LE expression .)
    <               reduce using rule 29 (expression -> expression LE expression .)
    GE              reduce using rule 29 (expression -> expression LE expression .)
    LE              reduce using rule 29 (expression -> expression LE expression .)
    NEQS            reduce using rule 29 (expression -> expression LE expression .)
    OR              reduce using rule 29 (expression -> expression LE expression .)
    NAND            reduce using rule 29 (expression -> expression LE expression .)
    $end            reduce using rule 29 (expression -> expression LE expression .)
    }               reduce using rule 29 (expression -> expression LE expression .)
    ;               reduce using rule 29 (expression -> expression LE expression .)
    THEN            reduce using rule 29 (expression -> expression LE expression .)
    ,               reduce using rule 29 (expression -> expression LE expression .)
    LAMBDA          reduce using rule 29 (expression -> expression LE expression .)
    DO              reduce using rule 29 (expression -> expression LE expression .)
    )               reduce using rule 29 (expression -> expression LE expression .)
    ]               reduce using rule 29 (expression -> expression LE expression .)
    IN              reduce using rule 29 (expression -> expression LE expression .)
    ELSE            reduce using rule 29 (expression -> expression LE expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27

  ! +               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]
  ! GE              [ shift and go to state 33 ]
  ! LE              [ shift and go to state 34 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 72

    (30) expression -> expression NEQS expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 30 (expression -> expression NEQS expression .)
    EQ              reduce using rule 30 (expression -> expression NEQS expression .)
    =               reduce using rule 30 (expression -> expression NEQS expression .)
    NEQS            reduce using rule 30 (expression -> expression NEQS expression .)
    OR              reduce using rule 30 (expression -> expression NEQS expression .)
    NAND            reduce using rule 30 (expression -> expression NEQS expression .)
    $end            reduce using rule 30 (expression -> expression NEQS expression .)
    }               reduce using rule 30 (expression -> expression NEQS expression .)
    ;               reduce using rule 30 (expression -> expression NEQS expression .)
    THEN            reduce using rule 30 (expression -> expression NEQS expression .)
    ,               reduce using rule 30 (expression -> expression NEQS expression .)
    LAMBDA          reduce using rule 30 (expression -> expression NEQS expression .)
    DO              reduce using rule 30 (expression -> expression NEQS expression .)
    )               reduce using rule 30 (expression -> expression NEQS expression .)
    ]               reduce using rule 30 (expression -> expression NEQS expression .)
    IN              reduce using rule 30 (expression -> expression NEQS expression .)
    ELSE            reduce using rule 30 (expression -> expression NEQS expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34

  ! +               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! -               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! *               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! /               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! >               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! <               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! GE              [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! LE              [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 29 ]
  ! =               [ shift and go to state 30 ]
  ! NEQS            [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 73

    (31) expression -> expression OR expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    OR              reduce using rule 31 (expression -> expression OR expression .)
    $end            reduce using rule 31 (expression -> expression OR expression .)
    }               reduce using rule 31 (expression -> expression OR expression .)
    ;               reduce using rule 31 (expression -> expression OR expression .)
    THEN            reduce using rule 31 (expression -> expression OR expression .)
    ,               reduce using rule 31 (expression -> expression OR expression .)
    LAMBDA          reduce using rule 31 (expression -> expression OR expression .)
    DO              reduce using rule 31 (expression -> expression OR expression .)
    )               reduce using rule 31 (expression -> expression OR expression .)
    ]               reduce using rule 31 (expression -> expression OR expression .)
    IN              reduce using rule 31 (expression -> expression OR expression .)
    ELSE            reduce using rule 31 (expression -> expression OR expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    NAND            shift and go to state 37

  ! +               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! =               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! NEQS            [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! NAND            [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 36 ]


state 74

    (32) expression -> expression NAND expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 32 (expression -> expression NAND expression .)
    OR              reduce using rule 32 (expression -> expression NAND expression .)
    NAND            reduce using rule 32 (expression -> expression NAND expression .)
    $end            reduce using rule 32 (expression -> expression NAND expression .)
    }               reduce using rule 32 (expression -> expression NAND expression .)
    ;               reduce using rule 32 (expression -> expression NAND expression .)
    THEN            reduce using rule 32 (expression -> expression NAND expression .)
    ,               reduce using rule 32 (expression -> expression NAND expression .)
    LAMBDA          reduce using rule 32 (expression -> expression NAND expression .)
    DO              reduce using rule 32 (expression -> expression NAND expression .)
    )               reduce using rule 32 (expression -> expression NAND expression .)
    ]               reduce using rule 32 (expression -> expression NAND expression .)
    IN              reduce using rule 32 (expression -> expression NAND expression .)
    ELSE            reduce using rule 32 (expression -> expression NAND expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35

  ! +               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! -               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! *               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! /               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! EQ              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! =               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! >               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! <               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! GE              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! LE              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! NEQS            [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! AND             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 36 ]
  ! NAND            [ shift and go to state 37 ]


state 75

    (6) expression -> STRUCT { sequence_struct . }
    (55) sequence_struct -> sequence_struct . ; seq_assign_expression

    }               shift and go to state 98
    ;               shift and go to state 99


state 76

    (54) sequence_struct -> seq_assign_expression .

    }               reduce using rule 54 (sequence_struct -> seq_assign_expression .)
    ;               reduce using rule 54 (sequence_struct -> seq_assign_expression .)


state 77

    (53) seq_assign_expression -> dots . ID ASSIGN expression

    ID              shift and go to state 100


state 78

    (10) expression -> { sequence } .

    +               reduce using rule 10 (expression -> { sequence } .)
    -               reduce using rule 10 (expression -> { sequence } .)
    *               reduce using rule 10 (expression -> { sequence } .)
    /               reduce using rule 10 (expression -> { sequence } .)
    AND             reduce using rule 10 (expression -> { sequence } .)
    EQ              reduce using rule 10 (expression -> { sequence } .)
    =               reduce using rule 10 (expression -> { sequence } .)
    >               reduce using rule 10 (expression -> { sequence } .)
    <               reduce using rule 10 (expression -> { sequence } .)
    GE              reduce using rule 10 (expression -> { sequence } .)
    LE              reduce using rule 10 (expression -> { sequence } .)
    NEQS            reduce using rule 10 (expression -> { sequence } .)
    OR              reduce using rule 10 (expression -> { sequence } .)
    NAND            reduce using rule 10 (expression -> { sequence } .)
    $end            reduce using rule 10 (expression -> { sequence } .)
    }               reduce using rule 10 (expression -> { sequence } .)
    ;               reduce using rule 10 (expression -> { sequence } .)
    THEN            reduce using rule 10 (expression -> { sequence } .)
    ,               reduce using rule 10 (expression -> { sequence } .)
    LAMBDA          reduce using rule 10 (expression -> { sequence } .)
    DO              reduce using rule 10 (expression -> { sequence } .)
    )               reduce using rule 10 (expression -> { sequence } .)
    ]               reduce using rule 10 (expression -> { sequence } .)
    IN              reduce using rule 10 (expression -> { sequence } .)
    ELSE            reduce using rule 10 (expression -> { sequence } .)


state 79

    (19) sequence -> sequence ; . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 101
    dots                           shift and go to state 15

state 80

    (11) expression -> EXTEND ID { . sequence_struct }
    (54) sequence_struct -> . seq_assign_expression
    (55) sequence_struct -> . sequence_struct ; seq_assign_expression
    (53) seq_assign_expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    .               shift and go to state 23

    sequence_struct                shift and go to state 102
    seq_assign_expression          shift and go to state 76
    dots                           shift and go to state 77

state 81

    (36) expression -> ID dots ID .
    (43) expression -> ID dots ID . ( )
    (44) expression -> ID dots ID . ( expression_list )

    +               reduce using rule 36 (expression -> ID dots ID .)
    -               reduce using rule 36 (expression -> ID dots ID .)
    *               reduce using rule 36 (expression -> ID dots ID .)
    /               reduce using rule 36 (expression -> ID dots ID .)
    AND             reduce using rule 36 (expression -> ID dots ID .)
    EQ              reduce using rule 36 (expression -> ID dots ID .)
    =               reduce using rule 36 (expression -> ID dots ID .)
    >               reduce using rule 36 (expression -> ID dots ID .)
    <               reduce using rule 36 (expression -> ID dots ID .)
    GE              reduce using rule 36 (expression -> ID dots ID .)
    LE              reduce using rule 36 (expression -> ID dots ID .)
    NEQS            reduce using rule 36 (expression -> ID dots ID .)
    OR              reduce using rule 36 (expression -> ID dots ID .)
    NAND            reduce using rule 36 (expression -> ID dots ID .)
    $end            reduce using rule 36 (expression -> ID dots ID .)
    }               reduce using rule 36 (expression -> ID dots ID .)
    ;               reduce using rule 36 (expression -> ID dots ID .)
    THEN            reduce using rule 36 (expression -> ID dots ID .)
    ,               reduce using rule 36 (expression -> ID dots ID .)
    LAMBDA          reduce using rule 36 (expression -> ID dots ID .)
    DO              reduce using rule 36 (expression -> ID dots ID .)
    )               reduce using rule 36 (expression -> ID dots ID .)
    ]               reduce using rule 36 (expression -> ID dots ID .)
    IN              reduce using rule 36 (expression -> ID dots ID .)
    ELSE            reduce using rule 36 (expression -> ID dots ID .)
    (               shift and go to state 103


state 82

    (40) expression -> ID ( ) .

    +               reduce using rule 40 (expression -> ID ( ) .)
    -               reduce using rule 40 (expression -> ID ( ) .)
    *               reduce using rule 40 (expression -> ID ( ) .)
    /               reduce using rule 40 (expression -> ID ( ) .)
    AND             reduce using rule 40 (expression -> ID ( ) .)
    EQ              reduce using rule 40 (expression -> ID ( ) .)
    =               reduce using rule 40 (expression -> ID ( ) .)
    >               reduce using rule 40 (expression -> ID ( ) .)
    <               reduce using rule 40 (expression -> ID ( ) .)
    GE              reduce using rule 40 (expression -> ID ( ) .)
    LE              reduce using rule 40 (expression -> ID ( ) .)
    NEQS            reduce using rule 40 (expression -> ID ( ) .)
    OR              reduce using rule 40 (expression -> ID ( ) .)
    NAND            reduce using rule 40 (expression -> ID ( ) .)
    $end            reduce using rule 40 (expression -> ID ( ) .)
    }               reduce using rule 40 (expression -> ID ( ) .)
    ;               reduce using rule 40 (expression -> ID ( ) .)
    THEN            reduce using rule 40 (expression -> ID ( ) .)
    ,               reduce using rule 40 (expression -> ID ( ) .)
    LAMBDA          reduce using rule 40 (expression -> ID ( ) .)
    DO              reduce using rule 40 (expression -> ID ( ) .)
    )               reduce using rule 40 (expression -> ID ( ) .)
    ]               reduce using rule 40 (expression -> ID ( ) .)
    IN              reduce using rule 40 (expression -> ID ( ) .)
    ELSE            reduce using rule 40 (expression -> ID ( ) .)


state 83

    (41) expression -> ID ( expression_list . )

    )               shift and go to state 104


state 84

    (48) expression -> ID [ NUMBER . ]

    ]               shift and go to state 105


state 85

    (51) expression -> ID ASSIGN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 51 (expression -> ID ASSIGN expression .)
    }               reduce using rule 51 (expression -> ID ASSIGN expression .)
    ;               reduce using rule 51 (expression -> ID ASSIGN expression .)
    THEN            reduce using rule 51 (expression -> ID ASSIGN expression .)
    ,               reduce using rule 51 (expression -> ID ASSIGN expression .)
    LAMBDA          reduce using rule 51 (expression -> ID ASSIGN expression .)
    DO              reduce using rule 51 (expression -> ID ASSIGN expression .)
    )               reduce using rule 51 (expression -> ID ASSIGN expression .)
    ]               reduce using rule 51 (expression -> ID ASSIGN expression .)
    IN              reduce using rule 51 (expression -> ID ASSIGN expression .)
    ELSE            reduce using rule 51 (expression -> ID ASSIGN expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! -               [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! *               [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! /               [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! AND             [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! EQ              [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! =               [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! >               [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! <               [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! GE              [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! LE              [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! NEQS            [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! OR              [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]
  ! NAND            [ reduce using rule 51 (expression -> ID ASSIGN expression .) ]


state 86

    (12) expression -> LOCAL ID ASSIGN . expression IN expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 106
    dots                           shift and go to state 15

state 87

    (14) expression -> IF expression THEN . expression
    (21) expression -> IF expression THEN . expression ELSE expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 107
    dots                           shift and go to state 15

state 88

    (15) expression -> IMPORT ID AS . ID

    ID              shift and go to state 108


state 89

    (33) expression -> LAMBDA_START LAMBDA expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    }               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ;               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    THEN            reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ,               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    LAMBDA          reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    DO              reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    )               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ]               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    IN              reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ELSE            reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! -               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! *               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! /               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! AND             [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! EQ              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! =               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! >               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! <               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! GE              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! LE              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! NEQS            [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! OR              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! NAND            [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]


state 90

    (7) expression_list -> expression , . expression_list
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 51
    expression_list                shift and go to state 109
    dots                           shift and go to state 15

state 91

    (34) expression -> LAMBDA_START expression_list LAMBDA . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 110
    dots                           shift and go to state 15

state 92

    (52) expression -> dots ID ASSIGN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    dots                           shift and go to state 15
    expression                     shift and go to state 111

state 93

    (37) expression -> LOOP expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 112
    dots                           shift and go to state 15

state 94

    (39) expression -> FOR expression ; . expression ; expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 113
    dots                           shift and go to state 15

state 95

    (49) expression -> ( expression_list ) .

    +               reduce using rule 49 (expression -> ( expression_list ) .)
    -               reduce using rule 49 (expression -> ( expression_list ) .)
    *               reduce using rule 49 (expression -> ( expression_list ) .)
    /               reduce using rule 49 (expression -> ( expression_list ) .)
    AND             reduce using rule 49 (expression -> ( expression_list ) .)
    EQ              reduce using rule 49 (expression -> ( expression_list ) .)
    =               reduce using rule 49 (expression -> ( expression_list ) .)
    >               reduce using rule 49 (expression -> ( expression_list ) .)
    <               reduce using rule 49 (expression -> ( expression_list ) .)
    GE              reduce using rule 49 (expression -> ( expression_list ) .)
    LE              reduce using rule 49 (expression -> ( expression_list ) .)
    NEQS            reduce using rule 49 (expression -> ( expression_list ) .)
    OR              reduce using rule 49 (expression -> ( expression_list ) .)
    NAND            reduce using rule 49 (expression -> ( expression_list ) .)
    $end            reduce using rule 49 (expression -> ( expression_list ) .)
    }               reduce using rule 49 (expression -> ( expression_list ) .)
    ;               reduce using rule 49 (expression -> ( expression_list ) .)
    THEN            reduce using rule 49 (expression -> ( expression_list ) .)
    ,               reduce using rule 49 (expression -> ( expression_list ) .)
    LAMBDA          reduce using rule 49 (expression -> ( expression_list ) .)
    DO              reduce using rule 49 (expression -> ( expression_list ) .)
    )               reduce using rule 49 (expression -> ( expression_list ) .)
    ]               reduce using rule 49 (expression -> ( expression_list ) .)
    IN              reduce using rule 49 (expression -> ( expression_list ) .)
    ELSE            reduce using rule 49 (expression -> ( expression_list ) .)


state 96

    (45) expression -> WHILE expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 114
    dots                           shift and go to state 15

state 97

    (47) expression -> [ expression_list ] .

    +               reduce using rule 47 (expression -> [ expression_list ] .)
    -               reduce using rule 47 (expression -> [ expression_list ] .)
    *               reduce using rule 47 (expression -> [ expression_list ] .)
    /               reduce using rule 47 (expression -> [ expression_list ] .)
    AND             reduce using rule 47 (expression -> [ expression_list ] .)
    EQ              reduce using rule 47 (expression -> [ expression_list ] .)
    =               reduce using rule 47 (expression -> [ expression_list ] .)
    >               reduce using rule 47 (expression -> [ expression_list ] .)
    <               reduce using rule 47 (expression -> [ expression_list ] .)
    GE              reduce using rule 47 (expression -> [ expression_list ] .)
    LE              reduce using rule 47 (expression -> [ expression_list ] .)
    NEQS            reduce using rule 47 (expression -> [ expression_list ] .)
    OR              reduce using rule 47 (expression -> [ expression_list ] .)
    NAND            reduce using rule 47 (expression -> [ expression_list ] .)
    $end            reduce using rule 47 (expression -> [ expression_list ] .)
    }               reduce using rule 47 (expression -> [ expression_list ] .)
    ;               reduce using rule 47 (expression -> [ expression_list ] .)
    THEN            reduce using rule 47 (expression -> [ expression_list ] .)
    ,               reduce using rule 47 (expression -> [ expression_list ] .)
    LAMBDA          reduce using rule 47 (expression -> [ expression_list ] .)
    DO              reduce using rule 47 (expression -> [ expression_list ] .)
    )               reduce using rule 47 (expression -> [ expression_list ] .)
    ]               reduce using rule 47 (expression -> [ expression_list ] .)
    IN              reduce using rule 47 (expression -> [ expression_list ] .)
    ELSE            reduce using rule 47 (expression -> [ expression_list ] .)


state 98

    (6) expression -> STRUCT { sequence_struct } .

    +               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    -               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    *               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    /               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    AND             reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    EQ              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    =               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    >               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    <               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    GE              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    LE              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    NEQS            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    OR              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    NAND            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    $end            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    }               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ;               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    THEN            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ,               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    LAMBDA          reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    DO              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    )               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ]               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    IN              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ELSE            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)


state 99

    (55) sequence_struct -> sequence_struct ; . seq_assign_expression
    (53) seq_assign_expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    .               shift and go to state 23

    seq_assign_expression          shift and go to state 115
    dots                           shift and go to state 77

state 100

    (53) seq_assign_expression -> dots ID . ASSIGN expression

    ASSIGN          shift and go to state 116


state 101

    (19) sequence -> sequence ; expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 19 (sequence -> sequence ; expression .)
    ;               reduce using rule 19 (sequence -> sequence ; expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 102

    (11) expression -> EXTEND ID { sequence_struct . }
    (55) sequence_struct -> sequence_struct . ; seq_assign_expression

    }               shift and go to state 117
    ;               shift and go to state 99


state 103

    (43) expression -> ID dots ID ( . )
    (44) expression -> ID dots ID ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    )               shift and go to state 118
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    dots                           shift and go to state 15
    expression_list                shift and go to state 119
    expression                     shift and go to state 51

state 104

    (41) expression -> ID ( expression_list ) .

    +               reduce using rule 41 (expression -> ID ( expression_list ) .)
    -               reduce using rule 41 (expression -> ID ( expression_list ) .)
    *               reduce using rule 41 (expression -> ID ( expression_list ) .)
    /               reduce using rule 41 (expression -> ID ( expression_list ) .)
    AND             reduce using rule 41 (expression -> ID ( expression_list ) .)
    EQ              reduce using rule 41 (expression -> ID ( expression_list ) .)
    =               reduce using rule 41 (expression -> ID ( expression_list ) .)
    >               reduce using rule 41 (expression -> ID ( expression_list ) .)
    <               reduce using rule 41 (expression -> ID ( expression_list ) .)
    GE              reduce using rule 41 (expression -> ID ( expression_list ) .)
    LE              reduce using rule 41 (expression -> ID ( expression_list ) .)
    NEQS            reduce using rule 41 (expression -> ID ( expression_list ) .)
    OR              reduce using rule 41 (expression -> ID ( expression_list ) .)
    NAND            reduce using rule 41 (expression -> ID ( expression_list ) .)
    $end            reduce using rule 41 (expression -> ID ( expression_list ) .)
    }               reduce using rule 41 (expression -> ID ( expression_list ) .)
    ;               reduce using rule 41 (expression -> ID ( expression_list ) .)
    THEN            reduce using rule 41 (expression -> ID ( expression_list ) .)
    ,               reduce using rule 41 (expression -> ID ( expression_list ) .)
    LAMBDA          reduce using rule 41 (expression -> ID ( expression_list ) .)
    DO              reduce using rule 41 (expression -> ID ( expression_list ) .)
    )               reduce using rule 41 (expression -> ID ( expression_list ) .)
    ]               reduce using rule 41 (expression -> ID ( expression_list ) .)
    IN              reduce using rule 41 (expression -> ID ( expression_list ) .)
    ELSE            reduce using rule 41 (expression -> ID ( expression_list ) .)


state 105

    (48) expression -> ID [ NUMBER ] .

    +               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    -               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    *               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    /               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    AND             reduce using rule 48 (expression -> ID [ NUMBER ] .)
    EQ              reduce using rule 48 (expression -> ID [ NUMBER ] .)
    =               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    >               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    <               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    GE              reduce using rule 48 (expression -> ID [ NUMBER ] .)
    LE              reduce using rule 48 (expression -> ID [ NUMBER ] .)
    NEQS            reduce using rule 48 (expression -> ID [ NUMBER ] .)
    OR              reduce using rule 48 (expression -> ID [ NUMBER ] .)
    NAND            reduce using rule 48 (expression -> ID [ NUMBER ] .)
    $end            reduce using rule 48 (expression -> ID [ NUMBER ] .)
    }               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    ;               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    THEN            reduce using rule 48 (expression -> ID [ NUMBER ] .)
    ,               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    LAMBDA          reduce using rule 48 (expression -> ID [ NUMBER ] .)
    DO              reduce using rule 48 (expression -> ID [ NUMBER ] .)
    )               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    ]               reduce using rule 48 (expression -> ID [ NUMBER ] .)
    IN              reduce using rule 48 (expression -> ID [ NUMBER ] .)
    ELSE            reduce using rule 48 (expression -> ID [ NUMBER ] .)


state 106

    (12) expression -> LOCAL ID ASSIGN expression . IN expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    IN              shift and go to state 120
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 107

    (14) expression -> IF expression THEN expression .
    (21) expression -> IF expression THEN expression . ELSE expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 14 (expression -> IF expression THEN expression .)
    }               reduce using rule 14 (expression -> IF expression THEN expression .)
    ;               reduce using rule 14 (expression -> IF expression THEN expression .)
    THEN            reduce using rule 14 (expression -> IF expression THEN expression .)
    ,               reduce using rule 14 (expression -> IF expression THEN expression .)
    LAMBDA          reduce using rule 14 (expression -> IF expression THEN expression .)
    DO              reduce using rule 14 (expression -> IF expression THEN expression .)
    )               reduce using rule 14 (expression -> IF expression THEN expression .)
    ]               reduce using rule 14 (expression -> IF expression THEN expression .)
    IN              reduce using rule 14 (expression -> IF expression THEN expression .)
    ELSE            shift and go to state 121
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! -               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! *               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! /               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! AND             [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! EQ              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! =               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! >               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! <               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! GE              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! LE              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! NEQS            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! OR              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! NAND            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! ELSE            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]


state 108

    (15) expression -> IMPORT ID AS ID .

    +               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    -               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    *               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    /               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    AND             reduce using rule 15 (expression -> IMPORT ID AS ID .)
    EQ              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    =               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    >               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    <               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    GE              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    LE              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    NEQS            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    OR              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    NAND            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    $end            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    }               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ;               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    THEN            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ,               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    LAMBDA          reduce using rule 15 (expression -> IMPORT ID AS ID .)
    DO              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    )               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ]               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    IN              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ELSE            reduce using rule 15 (expression -> IMPORT ID AS ID .)


state 109

    (7) expression_list -> expression , expression_list .

    LAMBDA          reduce using rule 7 (expression_list -> expression , expression_list .)
    )               reduce using rule 7 (expression_list -> expression , expression_list .)
    ]               reduce using rule 7 (expression_list -> expression , expression_list .)


state 110

    (34) expression -> LAMBDA_START expression_list LAMBDA expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    }               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ;               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    THEN            reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ,               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    LAMBDA          reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    DO              reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    )               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ]               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    IN              reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ELSE            reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! -               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! *               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! /               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! AND             [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! EQ              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! =               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! >               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! <               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! GE              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! LE              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! NEQS            [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! OR              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! NAND            [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]


state 111

    (52) expression -> dots ID ASSIGN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    }               reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    ;               reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    THEN            reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    ,               reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    LAMBDA          reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    DO              reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    )               reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    ]               reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    IN              reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    ELSE            reduce using rule 52 (expression -> dots ID ASSIGN expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! -               [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! *               [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! /               [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! AND             [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! EQ              [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! =               [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! >               [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! <               [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! GE              [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! LE              [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! NEQS            [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! OR              [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]
  ! NAND            [ reduce using rule 52 (expression -> dots ID ASSIGN expression .) ]


state 112

    (37) expression -> LOOP expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 37 (expression -> LOOP expression DO expression .)
    }               reduce using rule 37 (expression -> LOOP expression DO expression .)
    ;               reduce using rule 37 (expression -> LOOP expression DO expression .)
    THEN            reduce using rule 37 (expression -> LOOP expression DO expression .)
    ,               reduce using rule 37 (expression -> LOOP expression DO expression .)
    LAMBDA          reduce using rule 37 (expression -> LOOP expression DO expression .)
    DO              reduce using rule 37 (expression -> LOOP expression DO expression .)
    )               reduce using rule 37 (expression -> LOOP expression DO expression .)
    ]               reduce using rule 37 (expression -> LOOP expression DO expression .)
    IN              reduce using rule 37 (expression -> LOOP expression DO expression .)
    ELSE            reduce using rule 37 (expression -> LOOP expression DO expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! -               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! *               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! /               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! AND             [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! EQ              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! =               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! >               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! <               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! GE              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! LE              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! NEQS            [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! OR              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! NAND            [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]


state 113

    (39) expression -> FOR expression ; expression . ; expression DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ;               shift and go to state 122
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 114

    (45) expression -> WHILE expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 45 (expression -> WHILE expression DO expression .)
    }               reduce using rule 45 (expression -> WHILE expression DO expression .)
    ;               reduce using rule 45 (expression -> WHILE expression DO expression .)
    THEN            reduce using rule 45 (expression -> WHILE expression DO expression .)
    ,               reduce using rule 45 (expression -> WHILE expression DO expression .)
    LAMBDA          reduce using rule 45 (expression -> WHILE expression DO expression .)
    DO              reduce using rule 45 (expression -> WHILE expression DO expression .)
    )               reduce using rule 45 (expression -> WHILE expression DO expression .)
    ]               reduce using rule 45 (expression -> WHILE expression DO expression .)
    IN              reduce using rule 45 (expression -> WHILE expression DO expression .)
    ELSE            reduce using rule 45 (expression -> WHILE expression DO expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! -               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! *               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! /               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! AND             [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! EQ              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! =               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! >               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! <               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! GE              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! LE              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! NEQS            [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! OR              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! NAND            [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]


state 115

    (55) sequence_struct -> sequence_struct ; seq_assign_expression .

    }               reduce using rule 55 (sequence_struct -> sequence_struct ; seq_assign_expression .)
    ;               reduce using rule 55 (sequence_struct -> sequence_struct ; seq_assign_expression .)


state 116

    (53) seq_assign_expression -> dots ID ASSIGN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    dots                           shift and go to state 15
    expression                     shift and go to state 123

state 117

    (11) expression -> EXTEND ID { sequence_struct } .

    +               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    -               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    *               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    /               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    AND             reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    EQ              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    =               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    >               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    <               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    GE              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    LE              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    NEQS            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    OR              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    NAND            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    $end            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    }               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ;               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    THEN            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ,               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    LAMBDA          reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    DO              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    )               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ]               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    IN              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ELSE            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)


state 118

    (43) expression -> ID dots ID ( ) .

    +               reduce using rule 43 (expression -> ID dots ID ( ) .)
    -               reduce using rule 43 (expression -> ID dots ID ( ) .)
    *               reduce using rule 43 (expression -> ID dots ID ( ) .)
    /               reduce using rule 43 (expression -> ID dots ID ( ) .)
    AND             reduce using rule 43 (expression -> ID dots ID ( ) .)
    EQ              reduce using rule 43 (expression -> ID dots ID ( ) .)
    =               reduce using rule 43 (expression -> ID dots ID ( ) .)
    >               reduce using rule 43 (expression -> ID dots ID ( ) .)
    <               reduce using rule 43 (expression -> ID dots ID ( ) .)
    GE              reduce using rule 43 (expression -> ID dots ID ( ) .)
    LE              reduce using rule 43 (expression -> ID dots ID ( ) .)
    NEQS            reduce using rule 43 (expression -> ID dots ID ( ) .)
    OR              reduce using rule 43 (expression -> ID dots ID ( ) .)
    NAND            reduce using rule 43 (expression -> ID dots ID ( ) .)
    $end            reduce using rule 43 (expression -> ID dots ID ( ) .)
    }               reduce using rule 43 (expression -> ID dots ID ( ) .)
    ;               reduce using rule 43 (expression -> ID dots ID ( ) .)
    THEN            reduce using rule 43 (expression -> ID dots ID ( ) .)
    ,               reduce using rule 43 (expression -> ID dots ID ( ) .)
    LAMBDA          reduce using rule 43 (expression -> ID dots ID ( ) .)
    DO              reduce using rule 43 (expression -> ID dots ID ( ) .)
    )               reduce using rule 43 (expression -> ID dots ID ( ) .)
    ]               reduce using rule 43 (expression -> ID dots ID ( ) .)
    IN              reduce using rule 43 (expression -> ID dots ID ( ) .)
    ELSE            reduce using rule 43 (expression -> ID dots ID ( ) .)


state 119

    (44) expression -> ID dots ID ( expression_list . )

    )               shift and go to state 124


state 120

    (12) expression -> LOCAL ID ASSIGN expression IN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 125
    dots                           shift and go to state 15

state 121

    (21) expression -> IF expression THEN expression ELSE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 126
    dots                           shift and go to state 15

state 122

    (39) expression -> FOR expression ; expression ; . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 127
    dots                           shift and go to state 15

state 123

    (53) seq_assign_expression -> dots ID ASSIGN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 53 (seq_assign_expression -> dots ID ASSIGN expression .)
    ;               reduce using rule 53 (seq_assign_expression -> dots ID ASSIGN expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 124

    (44) expression -> ID dots ID ( expression_list ) .

    +               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    -               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    *               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    /               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    AND             reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    EQ              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    =               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    >               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    <               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    GE              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    LE              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    NEQS            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    OR              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    NAND            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    $end            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    }               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ;               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    THEN            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ,               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    LAMBDA          reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    DO              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    )               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ]               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    IN              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ELSE            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)


state 125

    (12) expression -> LOCAL ID ASSIGN expression IN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for = resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NEQS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NAND resolved as shift
    $end            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    }               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ;               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    THEN            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ,               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    LAMBDA          reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    DO              reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    )               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ]               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    IN              reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ELSE            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! -               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! *               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! /               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! AND             [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! EQ              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! =               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! >               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! <               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! GE              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! LE              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! NEQS            [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! OR              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! NAND            [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]


state 126

    (21) expression -> IF expression THEN expression ELSE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    }               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ;               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    THEN            reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ,               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    LAMBDA          reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    DO              reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    )               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ]               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    IN              reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ELSE            reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! -               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! *               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! /               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! AND             [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! EQ              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! =               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! >               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! <               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! GE              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! LE              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! NEQS            [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! OR              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! NAND            [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]


state 127

    (39) expression -> FOR expression ; expression ; expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 128
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37


state 128

    (39) expression -> FOR expression ; expression ; expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . ID [ NUMBER ]
    (49) expression -> . ( expression_list )
    (50) expression -> . NOT expression
    (51) expression -> . ID ASSIGN expression
    (52) expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 22
    .               shift and go to state 23

    expression                     shift and go to state 129
    dots                           shift and go to state 15

state 129

    (39) expression -> FOR expression ; expression ; expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    }               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ;               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    THEN            reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ,               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    LAMBDA          reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    DO              reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    )               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ]               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    IN              reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ELSE            reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    /               shift and go to state 27
    AND             shift and go to state 28
    EQ              shift and go to state 29
    =               shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32
    GE              shift and go to state 33
    LE              shift and go to state 34
    NEQS            shift and go to state 35
    OR              shift and go to state 36
    NAND            shift and go to state 37

  ! +               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! -               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! *               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! /               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! AND             [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! EQ              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! =               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! >               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! <               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! GE              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! LE              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! NEQS            [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! OR              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! NAND            [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 125 resolved as shift
WARNING: shift/reduce conflict for - in state 125 resolved as shift
WARNING: shift/reduce conflict for * in state 125 resolved as shift
WARNING: shift/reduce conflict for / in state 125 resolved as shift
WARNING: shift/reduce conflict for AND in state 125 resolved as shift
WARNING: shift/reduce conflict for EQ in state 125 resolved as shift
WARNING: shift/reduce conflict for = in state 125 resolved as shift
WARNING: shift/reduce conflict for > in state 125 resolved as shift
WARNING: shift/reduce conflict for < in state 125 resolved as shift
WARNING: shift/reduce conflict for GE in state 125 resolved as shift
WARNING: shift/reduce conflict for LE in state 125 resolved as shift
WARNING: shift/reduce conflict for NEQS in state 125 resolved as shift
WARNING: shift/reduce conflict for OR in state 125 resolved as shift
WARNING: shift/reduce conflict for NAND in state 125 resolved as shift
