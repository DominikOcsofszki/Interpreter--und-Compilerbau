Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> expression
Rule 1     expression -> - expression
Rule 2     expression -> expression + expression
Rule 3     expression -> expression - expression
Rule 4     expression -> expression * expression
Rule 5     expression -> expression / expression
Rule 6     expression -> STRUCT { sequence_struct }
Rule 7     expression_list -> expression , expression_list
Rule 8     expression_list -> expression
Rule 9     expression -> NUMBER
Rule 10    expression -> { sequence }
Rule 11    expression -> EXTEND ID { sequence_struct }
Rule 12    expression -> LOCAL ID ASSIGN expression IN expression
Rule 13    expression -> BOOL
Rule 14    expression -> IF expression THEN expression
Rule 15    expression -> IMPORT ID AS ID
Rule 16    sequence_struct -> seq_struct_assign_expression
Rule 17    sequence_struct -> sequence_struct ; seq_struct_assign_expression
Rule 18    expression -> FLOAT
Rule 19    expression -> IF expression THEN expression ELSE expression
Rule 20    expression -> IMPORT ID
Rule 21    sequence -> expression
Rule 22    sequence -> sequence ; expression
Rule 23    expression -> expression AND expression
Rule 24    expression -> expression EQ expression
Rule 25    expression -> expression = expression
Rule 26    expression -> expression > expression
Rule 27    expression -> expression < expression
Rule 28    expression -> expression GE expression
Rule 29    expression -> expression LE expression
Rule 30    expression -> expression NEQS expression
Rule 31    expression -> expression OR expression
Rule 32    expression -> expression NAND expression
Rule 33    expression -> STRING
Rule 34    dots -> .
Rule 35    dots -> . dots
Rule 36    expression -> LOOP expression DO expression
Rule 37    expression -> CHAR
Rule 38    expression -> FOR expression ; expression ; expression DO expression
Rule 39    expression -> ID
Rule 40    expression -> ID ( )
Rule 41    expression -> ID ( expression_list )
Rule 42    expression -> ID dots ID
Rule 43    expression -> WHILE expression DO expression
Rule 44    expression -> ID dots ID ( )
Rule 45    expression -> ID dots ID ( expression_list )
Rule 46    expression -> [ expression_list ]
Rule 47    expression -> ID [ NUMBER ]
Rule 48    expression -> ( expression_list )
Rule 49    expression -> NOT expression
Rule 50    assign_expression -> ID ASSIGN expression
Rule 51    assign_expression -> ID ASSIGN lambda_expression
Rule 52    expression -> assign_expression
Rule 53    seq_struct_assign_expression -> . assign_expression
Rule 54    lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression
Rule 55    lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression
Rule 56    lambda_expression -> LAMBDA_START LAMBDA expression
Rule 57    lambda_expression -> LAMBDA_START expression_list LAMBDA expression

Terminals, with rules where they appear

(                    : 40 41 44 45 48
)                    : 40 41 44 45 48
*                    : 4
+                    : 2
,                    : 7
-                    : 1 3
.                    : 34 35 53
/                    : 5
;                    : 17 22 38 38
<                    : 27
=                    : 25
>                    : 26
AND                  : 23
AS                   : 15
ASSIGN               : 12 50 51
BOOL                 : 13
CHAR                 : 37
DO                   : 36 38 43
ELSE                 : 19
EQ                   : 24
EXTEND               : 11
FLOAT                : 18
FOR                  : 38
GE                   : 28
ID                   : 11 12 15 15 20 39 40 41 42 42 44 44 45 45 47 50 51
IF                   : 14 19
IMPORT               : 15 20
IN                   : 12
LAMBDA               : 54 55 56 57
LAMBDA_START         : 54 55 56 57
LE                   : 29
LOCAL                : 12
LOOP                 : 36
NAND                 : 32
NEQS                 : 30
NOT                  : 49
NUMBER               : 9 47
OR                   : 31
STRING               : 33
STRUCT               : 6
THEN                 : 14 19
WHILE                : 43
[                    : 46 47
]                    : 46 47
error                : 
{                    : 6 10 11
}                    : 6 10 11

Nonterminals, with rules where they appear

assign_expression    : 52 53
dots                 : 35 42 44 45
expression           : 1 2 2 3 3 4 4 5 5 7 8 12 12 14 14 19 19 19 21 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 36 36 38 38 38 38 43 43 49 50 56 57 0
expression_list      : 7 41 45 46 48 54 57
lambda_expression    : 51
seq_struct_assign_expression : 16 17 54 55
sequence             : 10 22
sequence_struct      : 6 11 17

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 1
    assign_expression              shift and go to state 21

state 1

    (0) S' -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 2

    (1) expression -> - . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 36
    assign_expression              shift and go to state 21

state 3

    (6) expression -> STRUCT . { sequence_struct }

    {               shift and go to state 37


state 4

    (10) expression -> { . sequence }
    (21) sequence -> . expression
    (22) sequence -> . sequence ; expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    sequence                       shift and go to state 38
    expression                     shift and go to state 39
    assign_expression              shift and go to state 21

state 5

    (9) expression -> NUMBER .

    +               reduce using rule 9 (expression -> NUMBER .)
    -               reduce using rule 9 (expression -> NUMBER .)
    *               reduce using rule 9 (expression -> NUMBER .)
    /               reduce using rule 9 (expression -> NUMBER .)
    AND             reduce using rule 9 (expression -> NUMBER .)
    EQ              reduce using rule 9 (expression -> NUMBER .)
    =               reduce using rule 9 (expression -> NUMBER .)
    >               reduce using rule 9 (expression -> NUMBER .)
    <               reduce using rule 9 (expression -> NUMBER .)
    GE              reduce using rule 9 (expression -> NUMBER .)
    LE              reduce using rule 9 (expression -> NUMBER .)
    NEQS            reduce using rule 9 (expression -> NUMBER .)
    OR              reduce using rule 9 (expression -> NUMBER .)
    NAND            reduce using rule 9 (expression -> NUMBER .)
    $end            reduce using rule 9 (expression -> NUMBER .)
    }               reduce using rule 9 (expression -> NUMBER .)
    ;               reduce using rule 9 (expression -> NUMBER .)
    THEN            reduce using rule 9 (expression -> NUMBER .)
    DO              reduce using rule 9 (expression -> NUMBER .)
    ,               reduce using rule 9 (expression -> NUMBER .)
    )               reduce using rule 9 (expression -> NUMBER .)
    ]               reduce using rule 9 (expression -> NUMBER .)
    LAMBDA          reduce using rule 9 (expression -> NUMBER .)
    IN              reduce using rule 9 (expression -> NUMBER .)
    ELSE            reduce using rule 9 (expression -> NUMBER .)


state 6

    (11) expression -> EXTEND . ID { sequence_struct }

    ID              shift and go to state 40


state 7

    (39) expression -> ID .
    (40) expression -> ID . ( )
    (41) expression -> ID . ( expression_list )
    (42) expression -> ID . dots ID
    (44) expression -> ID . dots ID ( )
    (45) expression -> ID . dots ID ( expression_list )
    (47) expression -> ID . [ NUMBER ]
    (50) assign_expression -> ID . ASSIGN expression
    (51) assign_expression -> ID . ASSIGN lambda_expression
    (34) dots -> . .
    (35) dots -> . . dots

    +               reduce using rule 39 (expression -> ID .)
    -               reduce using rule 39 (expression -> ID .)
    *               reduce using rule 39 (expression -> ID .)
    /               reduce using rule 39 (expression -> ID .)
    AND             reduce using rule 39 (expression -> ID .)
    EQ              reduce using rule 39 (expression -> ID .)
    =               reduce using rule 39 (expression -> ID .)
    >               reduce using rule 39 (expression -> ID .)
    <               reduce using rule 39 (expression -> ID .)
    GE              reduce using rule 39 (expression -> ID .)
    LE              reduce using rule 39 (expression -> ID .)
    NEQS            reduce using rule 39 (expression -> ID .)
    OR              reduce using rule 39 (expression -> ID .)
    NAND            reduce using rule 39 (expression -> ID .)
    $end            reduce using rule 39 (expression -> ID .)
    }               reduce using rule 39 (expression -> ID .)
    ;               reduce using rule 39 (expression -> ID .)
    THEN            reduce using rule 39 (expression -> ID .)
    DO              reduce using rule 39 (expression -> ID .)
    ,               reduce using rule 39 (expression -> ID .)
    )               reduce using rule 39 (expression -> ID .)
    ]               reduce using rule 39 (expression -> ID .)
    LAMBDA          reduce using rule 39 (expression -> ID .)
    IN              reduce using rule 39 (expression -> ID .)
    ELSE            reduce using rule 39 (expression -> ID .)
    (               shift and go to state 41
    [               shift and go to state 43
    ASSIGN          shift and go to state 44
    .               shift and go to state 45

    dots                           shift and go to state 42

state 8

    (12) expression -> LOCAL . ID ASSIGN expression IN expression

    ID              shift and go to state 46


state 9

    (13) expression -> BOOL .

    +               reduce using rule 13 (expression -> BOOL .)
    -               reduce using rule 13 (expression -> BOOL .)
    *               reduce using rule 13 (expression -> BOOL .)
    /               reduce using rule 13 (expression -> BOOL .)
    AND             reduce using rule 13 (expression -> BOOL .)
    EQ              reduce using rule 13 (expression -> BOOL .)
    =               reduce using rule 13 (expression -> BOOL .)
    >               reduce using rule 13 (expression -> BOOL .)
    <               reduce using rule 13 (expression -> BOOL .)
    GE              reduce using rule 13 (expression -> BOOL .)
    LE              reduce using rule 13 (expression -> BOOL .)
    NEQS            reduce using rule 13 (expression -> BOOL .)
    OR              reduce using rule 13 (expression -> BOOL .)
    NAND            reduce using rule 13 (expression -> BOOL .)
    $end            reduce using rule 13 (expression -> BOOL .)
    }               reduce using rule 13 (expression -> BOOL .)
    ;               reduce using rule 13 (expression -> BOOL .)
    THEN            reduce using rule 13 (expression -> BOOL .)
    DO              reduce using rule 13 (expression -> BOOL .)
    ,               reduce using rule 13 (expression -> BOOL .)
    )               reduce using rule 13 (expression -> BOOL .)
    ]               reduce using rule 13 (expression -> BOOL .)
    LAMBDA          reduce using rule 13 (expression -> BOOL .)
    IN              reduce using rule 13 (expression -> BOOL .)
    ELSE            reduce using rule 13 (expression -> BOOL .)


state 10

    (14) expression -> IF . expression THEN expression
    (19) expression -> IF . expression THEN expression ELSE expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 47
    assign_expression              shift and go to state 21

state 11

    (15) expression -> IMPORT . ID AS ID
    (20) expression -> IMPORT . ID

    ID              shift and go to state 48


state 12

    (18) expression -> FLOAT .

    +               reduce using rule 18 (expression -> FLOAT .)
    -               reduce using rule 18 (expression -> FLOAT .)
    *               reduce using rule 18 (expression -> FLOAT .)
    /               reduce using rule 18 (expression -> FLOAT .)
    AND             reduce using rule 18 (expression -> FLOAT .)
    EQ              reduce using rule 18 (expression -> FLOAT .)
    =               reduce using rule 18 (expression -> FLOAT .)
    >               reduce using rule 18 (expression -> FLOAT .)
    <               reduce using rule 18 (expression -> FLOAT .)
    GE              reduce using rule 18 (expression -> FLOAT .)
    LE              reduce using rule 18 (expression -> FLOAT .)
    NEQS            reduce using rule 18 (expression -> FLOAT .)
    OR              reduce using rule 18 (expression -> FLOAT .)
    NAND            reduce using rule 18 (expression -> FLOAT .)
    $end            reduce using rule 18 (expression -> FLOAT .)
    }               reduce using rule 18 (expression -> FLOAT .)
    ;               reduce using rule 18 (expression -> FLOAT .)
    THEN            reduce using rule 18 (expression -> FLOAT .)
    DO              reduce using rule 18 (expression -> FLOAT .)
    ,               reduce using rule 18 (expression -> FLOAT .)
    )               reduce using rule 18 (expression -> FLOAT .)
    ]               reduce using rule 18 (expression -> FLOAT .)
    LAMBDA          reduce using rule 18 (expression -> FLOAT .)
    IN              reduce using rule 18 (expression -> FLOAT .)
    ELSE            reduce using rule 18 (expression -> FLOAT .)


state 13

    (33) expression -> STRING .

    +               reduce using rule 33 (expression -> STRING .)
    -               reduce using rule 33 (expression -> STRING .)
    *               reduce using rule 33 (expression -> STRING .)
    /               reduce using rule 33 (expression -> STRING .)
    AND             reduce using rule 33 (expression -> STRING .)
    EQ              reduce using rule 33 (expression -> STRING .)
    =               reduce using rule 33 (expression -> STRING .)
    >               reduce using rule 33 (expression -> STRING .)
    <               reduce using rule 33 (expression -> STRING .)
    GE              reduce using rule 33 (expression -> STRING .)
    LE              reduce using rule 33 (expression -> STRING .)
    NEQS            reduce using rule 33 (expression -> STRING .)
    OR              reduce using rule 33 (expression -> STRING .)
    NAND            reduce using rule 33 (expression -> STRING .)
    $end            reduce using rule 33 (expression -> STRING .)
    }               reduce using rule 33 (expression -> STRING .)
    ;               reduce using rule 33 (expression -> STRING .)
    THEN            reduce using rule 33 (expression -> STRING .)
    DO              reduce using rule 33 (expression -> STRING .)
    ,               reduce using rule 33 (expression -> STRING .)
    )               reduce using rule 33 (expression -> STRING .)
    ]               reduce using rule 33 (expression -> STRING .)
    LAMBDA          reduce using rule 33 (expression -> STRING .)
    IN              reduce using rule 33 (expression -> STRING .)
    ELSE            reduce using rule 33 (expression -> STRING .)


state 14

    (36) expression -> LOOP . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 49
    assign_expression              shift and go to state 21

state 15

    (37) expression -> CHAR .

    +               reduce using rule 37 (expression -> CHAR .)
    -               reduce using rule 37 (expression -> CHAR .)
    *               reduce using rule 37 (expression -> CHAR .)
    /               reduce using rule 37 (expression -> CHAR .)
    AND             reduce using rule 37 (expression -> CHAR .)
    EQ              reduce using rule 37 (expression -> CHAR .)
    =               reduce using rule 37 (expression -> CHAR .)
    >               reduce using rule 37 (expression -> CHAR .)
    <               reduce using rule 37 (expression -> CHAR .)
    GE              reduce using rule 37 (expression -> CHAR .)
    LE              reduce using rule 37 (expression -> CHAR .)
    NEQS            reduce using rule 37 (expression -> CHAR .)
    OR              reduce using rule 37 (expression -> CHAR .)
    NAND            reduce using rule 37 (expression -> CHAR .)
    $end            reduce using rule 37 (expression -> CHAR .)
    }               reduce using rule 37 (expression -> CHAR .)
    ;               reduce using rule 37 (expression -> CHAR .)
    THEN            reduce using rule 37 (expression -> CHAR .)
    DO              reduce using rule 37 (expression -> CHAR .)
    ,               reduce using rule 37 (expression -> CHAR .)
    )               reduce using rule 37 (expression -> CHAR .)
    ]               reduce using rule 37 (expression -> CHAR .)
    LAMBDA          reduce using rule 37 (expression -> CHAR .)
    IN              reduce using rule 37 (expression -> CHAR .)
    ELSE            reduce using rule 37 (expression -> CHAR .)


state 16

    (38) expression -> FOR . expression ; expression ; expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 50
    assign_expression              shift and go to state 21

state 17

    (48) expression -> ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression_list                shift and go to state 51
    expression                     shift and go to state 52
    assign_expression              shift and go to state 21

state 18

    (43) expression -> WHILE . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 53
    assign_expression              shift and go to state 21

state 19

    (46) expression -> [ . expression_list ]
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression_list                shift and go to state 54
    expression                     shift and go to state 52
    assign_expression              shift and go to state 21

state 20

    (49) expression -> NOT . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 55
    assign_expression              shift and go to state 21

state 21

    (52) expression -> assign_expression .

    +               reduce using rule 52 (expression -> assign_expression .)
    -               reduce using rule 52 (expression -> assign_expression .)
    *               reduce using rule 52 (expression -> assign_expression .)
    /               reduce using rule 52 (expression -> assign_expression .)
    AND             reduce using rule 52 (expression -> assign_expression .)
    EQ              reduce using rule 52 (expression -> assign_expression .)
    =               reduce using rule 52 (expression -> assign_expression .)
    >               reduce using rule 52 (expression -> assign_expression .)
    <               reduce using rule 52 (expression -> assign_expression .)
    GE              reduce using rule 52 (expression -> assign_expression .)
    LE              reduce using rule 52 (expression -> assign_expression .)
    NEQS            reduce using rule 52 (expression -> assign_expression .)
    OR              reduce using rule 52 (expression -> assign_expression .)
    NAND            reduce using rule 52 (expression -> assign_expression .)
    $end            reduce using rule 52 (expression -> assign_expression .)
    }               reduce using rule 52 (expression -> assign_expression .)
    ;               reduce using rule 52 (expression -> assign_expression .)
    THEN            reduce using rule 52 (expression -> assign_expression .)
    DO              reduce using rule 52 (expression -> assign_expression .)
    ,               reduce using rule 52 (expression -> assign_expression .)
    )               reduce using rule 52 (expression -> assign_expression .)
    ]               reduce using rule 52 (expression -> assign_expression .)
    LAMBDA          reduce using rule 52 (expression -> assign_expression .)
    IN              reduce using rule 52 (expression -> assign_expression .)
    ELSE            reduce using rule 52 (expression -> assign_expression .)


state 22

    (2) expression -> expression + . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 56
    assign_expression              shift and go to state 21

state 23

    (3) expression -> expression - . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 57
    assign_expression              shift and go to state 21

state 24

    (4) expression -> expression * . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 58
    assign_expression              shift and go to state 21

state 25

    (5) expression -> expression / . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 59
    assign_expression              shift and go to state 21

state 26

    (23) expression -> expression AND . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 60
    assign_expression              shift and go to state 21

state 27

    (24) expression -> expression EQ . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 61
    assign_expression              shift and go to state 21

state 28

    (25) expression -> expression = . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 62
    assign_expression              shift and go to state 21

state 29

    (26) expression -> expression > . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 63
    assign_expression              shift and go to state 21

state 30

    (27) expression -> expression < . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 64
    assign_expression              shift and go to state 21

state 31

    (28) expression -> expression GE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 65
    assign_expression              shift and go to state 21

state 32

    (29) expression -> expression LE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 66
    assign_expression              shift and go to state 21

state 33

    (30) expression -> expression NEQS . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 67
    assign_expression              shift and go to state 21

state 34

    (31) expression -> expression OR . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 68
    assign_expression              shift and go to state 21

state 35

    (32) expression -> expression NAND . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 69
    assign_expression              shift and go to state 21

state 36

    (1) expression -> - expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 1 (expression -> - expression .)
    -               reduce using rule 1 (expression -> - expression .)
    *               reduce using rule 1 (expression -> - expression .)
    /               reduce using rule 1 (expression -> - expression .)
    AND             reduce using rule 1 (expression -> - expression .)
    EQ              reduce using rule 1 (expression -> - expression .)
    =               reduce using rule 1 (expression -> - expression .)
    >               reduce using rule 1 (expression -> - expression .)
    <               reduce using rule 1 (expression -> - expression .)
    GE              reduce using rule 1 (expression -> - expression .)
    LE              reduce using rule 1 (expression -> - expression .)
    NEQS            reduce using rule 1 (expression -> - expression .)
    OR              reduce using rule 1 (expression -> - expression .)
    NAND            reduce using rule 1 (expression -> - expression .)
    $end            reduce using rule 1 (expression -> - expression .)
    }               reduce using rule 1 (expression -> - expression .)
    ;               reduce using rule 1 (expression -> - expression .)
    THEN            reduce using rule 1 (expression -> - expression .)
    DO              reduce using rule 1 (expression -> - expression .)
    ,               reduce using rule 1 (expression -> - expression .)
    )               reduce using rule 1 (expression -> - expression .)
    ]               reduce using rule 1 (expression -> - expression .)
    LAMBDA          reduce using rule 1 (expression -> - expression .)
    IN              reduce using rule 1 (expression -> - expression .)
    ELSE            reduce using rule 1 (expression -> - expression .)

  ! +               [ shift and go to state 22 ]
  ! -               [ shift and go to state 23 ]
  ! *               [ shift and go to state 24 ]
  ! /               [ shift and go to state 25 ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 37

    (6) expression -> STRUCT { . sequence_struct }
    (16) sequence_struct -> . seq_struct_assign_expression
    (17) sequence_struct -> . sequence_struct ; seq_struct_assign_expression
    (53) seq_struct_assign_expression -> . . assign_expression

    .               shift and go to state 72

    sequence_struct                shift and go to state 70
    seq_struct_assign_expression   shift and go to state 71

state 38

    (10) expression -> { sequence . }
    (22) sequence -> sequence . ; expression

    }               shift and go to state 73
    ;               shift and go to state 74


state 39

    (21) sequence -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 21 (sequence -> expression .)
    ;               reduce using rule 21 (sequence -> expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 40

    (11) expression -> EXTEND ID . { sequence_struct }

    {               shift and go to state 75


state 41

    (40) expression -> ID ( . )
    (41) expression -> ID ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    )               shift and go to state 76
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression_list                shift and go to state 77
    expression                     shift and go to state 52
    assign_expression              shift and go to state 21

state 42

    (42) expression -> ID dots . ID
    (44) expression -> ID dots . ID ( )
    (45) expression -> ID dots . ID ( expression_list )

    ID              shift and go to state 78


state 43

    (47) expression -> ID [ . NUMBER ]

    NUMBER          shift and go to state 79


state 44

    (50) assign_expression -> ID ASSIGN . expression
    (51) assign_expression -> ID ASSIGN . lambda_expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (54) lambda_expression -> . LAMBDA_START expression_list LAMBDA seq_struct_assign_expression
    (55) lambda_expression -> . LAMBDA_START LAMBDA seq_struct_assign_expression
    (56) lambda_expression -> . LAMBDA_START LAMBDA expression
    (57) lambda_expression -> . LAMBDA_START expression_list LAMBDA expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20
    LAMBDA_START    shift and go to state 82

    expression                     shift and go to state 80
    lambda_expression              shift and go to state 81
    assign_expression              shift and go to state 21

state 45

    (34) dots -> . .
    (35) dots -> . . dots
    (34) dots -> . .
    (35) dots -> . . dots

    ID              reduce using rule 34 (dots -> . .)
    .               shift and go to state 45

    dots                           shift and go to state 83

state 46

    (12) expression -> LOCAL ID . ASSIGN expression IN expression

    ASSIGN          shift and go to state 84


state 47

    (14) expression -> IF expression . THEN expression
    (19) expression -> IF expression . THEN expression ELSE expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    THEN            shift and go to state 85
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 48

    (15) expression -> IMPORT ID . AS ID
    (20) expression -> IMPORT ID .

    AS              shift and go to state 86
    +               reduce using rule 20 (expression -> IMPORT ID .)
    -               reduce using rule 20 (expression -> IMPORT ID .)
    *               reduce using rule 20 (expression -> IMPORT ID .)
    /               reduce using rule 20 (expression -> IMPORT ID .)
    AND             reduce using rule 20 (expression -> IMPORT ID .)
    EQ              reduce using rule 20 (expression -> IMPORT ID .)
    =               reduce using rule 20 (expression -> IMPORT ID .)
    >               reduce using rule 20 (expression -> IMPORT ID .)
    <               reduce using rule 20 (expression -> IMPORT ID .)
    GE              reduce using rule 20 (expression -> IMPORT ID .)
    LE              reduce using rule 20 (expression -> IMPORT ID .)
    NEQS            reduce using rule 20 (expression -> IMPORT ID .)
    OR              reduce using rule 20 (expression -> IMPORT ID .)
    NAND            reduce using rule 20 (expression -> IMPORT ID .)
    $end            reduce using rule 20 (expression -> IMPORT ID .)
    }               reduce using rule 20 (expression -> IMPORT ID .)
    ;               reduce using rule 20 (expression -> IMPORT ID .)
    THEN            reduce using rule 20 (expression -> IMPORT ID .)
    DO              reduce using rule 20 (expression -> IMPORT ID .)
    ,               reduce using rule 20 (expression -> IMPORT ID .)
    )               reduce using rule 20 (expression -> IMPORT ID .)
    ]               reduce using rule 20 (expression -> IMPORT ID .)
    LAMBDA          reduce using rule 20 (expression -> IMPORT ID .)
    IN              reduce using rule 20 (expression -> IMPORT ID .)
    ELSE            reduce using rule 20 (expression -> IMPORT ID .)


state 49

    (36) expression -> LOOP expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 87
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 50

    (38) expression -> FOR expression . ; expression ; expression DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ;               shift and go to state 88
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 51

    (48) expression -> ( expression_list . )

    )               shift and go to state 89


state 52

    (7) expression_list -> expression . , expression_list
    (8) expression_list -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ,               shift and go to state 90
    )               reduce using rule 8 (expression_list -> expression .)
    ]               reduce using rule 8 (expression_list -> expression .)
    LAMBDA          reduce using rule 8 (expression_list -> expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 53

    (43) expression -> WHILE expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 91
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 54

    (46) expression -> [ expression_list . ]

    ]               shift and go to state 92


state 55

    (49) expression -> NOT expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 49 (expression -> NOT expression .)
    -               reduce using rule 49 (expression -> NOT expression .)
    *               reduce using rule 49 (expression -> NOT expression .)
    /               reduce using rule 49 (expression -> NOT expression .)
    AND             reduce using rule 49 (expression -> NOT expression .)
    EQ              reduce using rule 49 (expression -> NOT expression .)
    =               reduce using rule 49 (expression -> NOT expression .)
    >               reduce using rule 49 (expression -> NOT expression .)
    <               reduce using rule 49 (expression -> NOT expression .)
    GE              reduce using rule 49 (expression -> NOT expression .)
    LE              reduce using rule 49 (expression -> NOT expression .)
    NEQS            reduce using rule 49 (expression -> NOT expression .)
    OR              reduce using rule 49 (expression -> NOT expression .)
    NAND            reduce using rule 49 (expression -> NOT expression .)
    $end            reduce using rule 49 (expression -> NOT expression .)
    }               reduce using rule 49 (expression -> NOT expression .)
    ;               reduce using rule 49 (expression -> NOT expression .)
    THEN            reduce using rule 49 (expression -> NOT expression .)
    DO              reduce using rule 49 (expression -> NOT expression .)
    ,               reduce using rule 49 (expression -> NOT expression .)
    )               reduce using rule 49 (expression -> NOT expression .)
    ]               reduce using rule 49 (expression -> NOT expression .)
    LAMBDA          reduce using rule 49 (expression -> NOT expression .)
    IN              reduce using rule 49 (expression -> NOT expression .)
    ELSE            reduce using rule 49 (expression -> NOT expression .)

  ! +               [ shift and go to state 22 ]
  ! -               [ shift and go to state 23 ]
  ! *               [ shift and go to state 24 ]
  ! /               [ shift and go to state 25 ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 56

    (2) expression -> expression + expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 2 (expression -> expression + expression .)
    -               reduce using rule 2 (expression -> expression + expression .)
    AND             reduce using rule 2 (expression -> expression + expression .)
    EQ              reduce using rule 2 (expression -> expression + expression .)
    =               reduce using rule 2 (expression -> expression + expression .)
    >               reduce using rule 2 (expression -> expression + expression .)
    <               reduce using rule 2 (expression -> expression + expression .)
    GE              reduce using rule 2 (expression -> expression + expression .)
    LE              reduce using rule 2 (expression -> expression + expression .)
    NEQS            reduce using rule 2 (expression -> expression + expression .)
    OR              reduce using rule 2 (expression -> expression + expression .)
    NAND            reduce using rule 2 (expression -> expression + expression .)
    $end            reduce using rule 2 (expression -> expression + expression .)
    }               reduce using rule 2 (expression -> expression + expression .)
    ;               reduce using rule 2 (expression -> expression + expression .)
    THEN            reduce using rule 2 (expression -> expression + expression .)
    DO              reduce using rule 2 (expression -> expression + expression .)
    ,               reduce using rule 2 (expression -> expression + expression .)
    )               reduce using rule 2 (expression -> expression + expression .)
    ]               reduce using rule 2 (expression -> expression + expression .)
    LAMBDA          reduce using rule 2 (expression -> expression + expression .)
    IN              reduce using rule 2 (expression -> expression + expression .)
    ELSE            reduce using rule 2 (expression -> expression + expression .)
    *               shift and go to state 24
    /               shift and go to state 25

  ! *               [ reduce using rule 2 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 2 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 22 ]
  ! -               [ shift and go to state 23 ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 57

    (3) expression -> expression - expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 3 (expression -> expression - expression .)
    -               reduce using rule 3 (expression -> expression - expression .)
    AND             reduce using rule 3 (expression -> expression - expression .)
    EQ              reduce using rule 3 (expression -> expression - expression .)
    =               reduce using rule 3 (expression -> expression - expression .)
    >               reduce using rule 3 (expression -> expression - expression .)
    <               reduce using rule 3 (expression -> expression - expression .)
    GE              reduce using rule 3 (expression -> expression - expression .)
    LE              reduce using rule 3 (expression -> expression - expression .)
    NEQS            reduce using rule 3 (expression -> expression - expression .)
    OR              reduce using rule 3 (expression -> expression - expression .)
    NAND            reduce using rule 3 (expression -> expression - expression .)
    $end            reduce using rule 3 (expression -> expression - expression .)
    }               reduce using rule 3 (expression -> expression - expression .)
    ;               reduce using rule 3 (expression -> expression - expression .)
    THEN            reduce using rule 3 (expression -> expression - expression .)
    DO              reduce using rule 3 (expression -> expression - expression .)
    ,               reduce using rule 3 (expression -> expression - expression .)
    )               reduce using rule 3 (expression -> expression - expression .)
    ]               reduce using rule 3 (expression -> expression - expression .)
    LAMBDA          reduce using rule 3 (expression -> expression - expression .)
    IN              reduce using rule 3 (expression -> expression - expression .)
    ELSE            reduce using rule 3 (expression -> expression - expression .)
    *               shift and go to state 24
    /               shift and go to state 25

  ! *               [ reduce using rule 3 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 3 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 22 ]
  ! -               [ shift and go to state 23 ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 58

    (4) expression -> expression * expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 4 (expression -> expression * expression .)
    -               reduce using rule 4 (expression -> expression * expression .)
    *               reduce using rule 4 (expression -> expression * expression .)
    /               reduce using rule 4 (expression -> expression * expression .)
    AND             reduce using rule 4 (expression -> expression * expression .)
    EQ              reduce using rule 4 (expression -> expression * expression .)
    =               reduce using rule 4 (expression -> expression * expression .)
    >               reduce using rule 4 (expression -> expression * expression .)
    <               reduce using rule 4 (expression -> expression * expression .)
    GE              reduce using rule 4 (expression -> expression * expression .)
    LE              reduce using rule 4 (expression -> expression * expression .)
    NEQS            reduce using rule 4 (expression -> expression * expression .)
    OR              reduce using rule 4 (expression -> expression * expression .)
    NAND            reduce using rule 4 (expression -> expression * expression .)
    $end            reduce using rule 4 (expression -> expression * expression .)
    }               reduce using rule 4 (expression -> expression * expression .)
    ;               reduce using rule 4 (expression -> expression * expression .)
    THEN            reduce using rule 4 (expression -> expression * expression .)
    DO              reduce using rule 4 (expression -> expression * expression .)
    ,               reduce using rule 4 (expression -> expression * expression .)
    )               reduce using rule 4 (expression -> expression * expression .)
    ]               reduce using rule 4 (expression -> expression * expression .)
    LAMBDA          reduce using rule 4 (expression -> expression * expression .)
    IN              reduce using rule 4 (expression -> expression * expression .)
    ELSE            reduce using rule 4 (expression -> expression * expression .)

  ! +               [ shift and go to state 22 ]
  ! -               [ shift and go to state 23 ]
  ! *               [ shift and go to state 24 ]
  ! /               [ shift and go to state 25 ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 59

    (5) expression -> expression / expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 5 (expression -> expression / expression .)
    -               reduce using rule 5 (expression -> expression / expression .)
    *               reduce using rule 5 (expression -> expression / expression .)
    /               reduce using rule 5 (expression -> expression / expression .)
    AND             reduce using rule 5 (expression -> expression / expression .)
    EQ              reduce using rule 5 (expression -> expression / expression .)
    =               reduce using rule 5 (expression -> expression / expression .)
    >               reduce using rule 5 (expression -> expression / expression .)
    <               reduce using rule 5 (expression -> expression / expression .)
    GE              reduce using rule 5 (expression -> expression / expression .)
    LE              reduce using rule 5 (expression -> expression / expression .)
    NEQS            reduce using rule 5 (expression -> expression / expression .)
    OR              reduce using rule 5 (expression -> expression / expression .)
    NAND            reduce using rule 5 (expression -> expression / expression .)
    $end            reduce using rule 5 (expression -> expression / expression .)
    }               reduce using rule 5 (expression -> expression / expression .)
    ;               reduce using rule 5 (expression -> expression / expression .)
    THEN            reduce using rule 5 (expression -> expression / expression .)
    DO              reduce using rule 5 (expression -> expression / expression .)
    ,               reduce using rule 5 (expression -> expression / expression .)
    )               reduce using rule 5 (expression -> expression / expression .)
    ]               reduce using rule 5 (expression -> expression / expression .)
    LAMBDA          reduce using rule 5 (expression -> expression / expression .)
    IN              reduce using rule 5 (expression -> expression / expression .)
    ELSE            reduce using rule 5 (expression -> expression / expression .)

  ! +               [ shift and go to state 22 ]
  ! -               [ shift and go to state 23 ]
  ! *               [ shift and go to state 24 ]
  ! /               [ shift and go to state 25 ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 60

    (23) expression -> expression AND expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 23 (expression -> expression AND expression .)
    OR              reduce using rule 23 (expression -> expression AND expression .)
    NAND            reduce using rule 23 (expression -> expression AND expression .)
    $end            reduce using rule 23 (expression -> expression AND expression .)
    }               reduce using rule 23 (expression -> expression AND expression .)
    ;               reduce using rule 23 (expression -> expression AND expression .)
    THEN            reduce using rule 23 (expression -> expression AND expression .)
    DO              reduce using rule 23 (expression -> expression AND expression .)
    ,               reduce using rule 23 (expression -> expression AND expression .)
    )               reduce using rule 23 (expression -> expression AND expression .)
    ]               reduce using rule 23 (expression -> expression AND expression .)
    LAMBDA          reduce using rule 23 (expression -> expression AND expression .)
    IN              reduce using rule 23 (expression -> expression AND expression .)
    ELSE            reduce using rule 23 (expression -> expression AND expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33

  ! +               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! =               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! NEQS            [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 61

    (24) expression -> expression EQ expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 24 (expression -> expression EQ expression .)
    EQ              reduce using rule 24 (expression -> expression EQ expression .)
    =               reduce using rule 24 (expression -> expression EQ expression .)
    NEQS            reduce using rule 24 (expression -> expression EQ expression .)
    OR              reduce using rule 24 (expression -> expression EQ expression .)
    NAND            reduce using rule 24 (expression -> expression EQ expression .)
    $end            reduce using rule 24 (expression -> expression EQ expression .)
    }               reduce using rule 24 (expression -> expression EQ expression .)
    ;               reduce using rule 24 (expression -> expression EQ expression .)
    THEN            reduce using rule 24 (expression -> expression EQ expression .)
    DO              reduce using rule 24 (expression -> expression EQ expression .)
    ,               reduce using rule 24 (expression -> expression EQ expression .)
    )               reduce using rule 24 (expression -> expression EQ expression .)
    ]               reduce using rule 24 (expression -> expression EQ expression .)
    LAMBDA          reduce using rule 24 (expression -> expression EQ expression .)
    IN              reduce using rule 24 (expression -> expression EQ expression .)
    ELSE            reduce using rule 24 (expression -> expression EQ expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32

  ! +               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! >               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! <               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 62

    (25) expression -> expression = expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 25 (expression -> expression = expression .)
    EQ              reduce using rule 25 (expression -> expression = expression .)
    =               reduce using rule 25 (expression -> expression = expression .)
    NEQS            reduce using rule 25 (expression -> expression = expression .)
    OR              reduce using rule 25 (expression -> expression = expression .)
    NAND            reduce using rule 25 (expression -> expression = expression .)
    $end            reduce using rule 25 (expression -> expression = expression .)
    }               reduce using rule 25 (expression -> expression = expression .)
    ;               reduce using rule 25 (expression -> expression = expression .)
    THEN            reduce using rule 25 (expression -> expression = expression .)
    DO              reduce using rule 25 (expression -> expression = expression .)
    ,               reduce using rule 25 (expression -> expression = expression .)
    )               reduce using rule 25 (expression -> expression = expression .)
    ]               reduce using rule 25 (expression -> expression = expression .)
    LAMBDA          reduce using rule 25 (expression -> expression = expression .)
    IN              reduce using rule 25 (expression -> expression = expression .)
    ELSE            reduce using rule 25 (expression -> expression = expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32

  ! +               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! -               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! *               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! /               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! >               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! <               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! GE              [ reduce using rule 25 (expression -> expression = expression .) ]
  ! LE              [ reduce using rule 25 (expression -> expression = expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 63

    (26) expression -> expression > expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 26 (expression -> expression > expression .)
    EQ              reduce using rule 26 (expression -> expression > expression .)
    =               reduce using rule 26 (expression -> expression > expression .)
    >               reduce using rule 26 (expression -> expression > expression .)
    <               reduce using rule 26 (expression -> expression > expression .)
    GE              reduce using rule 26 (expression -> expression > expression .)
    LE              reduce using rule 26 (expression -> expression > expression .)
    NEQS            reduce using rule 26 (expression -> expression > expression .)
    OR              reduce using rule 26 (expression -> expression > expression .)
    NAND            reduce using rule 26 (expression -> expression > expression .)
    $end            reduce using rule 26 (expression -> expression > expression .)
    }               reduce using rule 26 (expression -> expression > expression .)
    ;               reduce using rule 26 (expression -> expression > expression .)
    THEN            reduce using rule 26 (expression -> expression > expression .)
    DO              reduce using rule 26 (expression -> expression > expression .)
    ,               reduce using rule 26 (expression -> expression > expression .)
    )               reduce using rule 26 (expression -> expression > expression .)
    ]               reduce using rule 26 (expression -> expression > expression .)
    LAMBDA          reduce using rule 26 (expression -> expression > expression .)
    IN              reduce using rule 26 (expression -> expression > expression .)
    ELSE            reduce using rule 26 (expression -> expression > expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25

  ! +               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 64

    (27) expression -> expression < expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 27 (expression -> expression < expression .)
    EQ              reduce using rule 27 (expression -> expression < expression .)
    =               reduce using rule 27 (expression -> expression < expression .)
    >               reduce using rule 27 (expression -> expression < expression .)
    <               reduce using rule 27 (expression -> expression < expression .)
    GE              reduce using rule 27 (expression -> expression < expression .)
    LE              reduce using rule 27 (expression -> expression < expression .)
    NEQS            reduce using rule 27 (expression -> expression < expression .)
    OR              reduce using rule 27 (expression -> expression < expression .)
    NAND            reduce using rule 27 (expression -> expression < expression .)
    $end            reduce using rule 27 (expression -> expression < expression .)
    }               reduce using rule 27 (expression -> expression < expression .)
    ;               reduce using rule 27 (expression -> expression < expression .)
    THEN            reduce using rule 27 (expression -> expression < expression .)
    DO              reduce using rule 27 (expression -> expression < expression .)
    ,               reduce using rule 27 (expression -> expression < expression .)
    )               reduce using rule 27 (expression -> expression < expression .)
    ]               reduce using rule 27 (expression -> expression < expression .)
    LAMBDA          reduce using rule 27 (expression -> expression < expression .)
    IN              reduce using rule 27 (expression -> expression < expression .)
    ELSE            reduce using rule 27 (expression -> expression < expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25

  ! +               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 65

    (28) expression -> expression GE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 28 (expression -> expression GE expression .)
    EQ              reduce using rule 28 (expression -> expression GE expression .)
    =               reduce using rule 28 (expression -> expression GE expression .)
    >               reduce using rule 28 (expression -> expression GE expression .)
    <               reduce using rule 28 (expression -> expression GE expression .)
    GE              reduce using rule 28 (expression -> expression GE expression .)
    LE              reduce using rule 28 (expression -> expression GE expression .)
    NEQS            reduce using rule 28 (expression -> expression GE expression .)
    OR              reduce using rule 28 (expression -> expression GE expression .)
    NAND            reduce using rule 28 (expression -> expression GE expression .)
    $end            reduce using rule 28 (expression -> expression GE expression .)
    }               reduce using rule 28 (expression -> expression GE expression .)
    ;               reduce using rule 28 (expression -> expression GE expression .)
    THEN            reduce using rule 28 (expression -> expression GE expression .)
    DO              reduce using rule 28 (expression -> expression GE expression .)
    ,               reduce using rule 28 (expression -> expression GE expression .)
    )               reduce using rule 28 (expression -> expression GE expression .)
    ]               reduce using rule 28 (expression -> expression GE expression .)
    LAMBDA          reduce using rule 28 (expression -> expression GE expression .)
    IN              reduce using rule 28 (expression -> expression GE expression .)
    ELSE            reduce using rule 28 (expression -> expression GE expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25

  ! +               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 66

    (29) expression -> expression LE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 29 (expression -> expression LE expression .)
    EQ              reduce using rule 29 (expression -> expression LE expression .)
    =               reduce using rule 29 (expression -> expression LE expression .)
    >               reduce using rule 29 (expression -> expression LE expression .)
    <               reduce using rule 29 (expression -> expression LE expression .)
    GE              reduce using rule 29 (expression -> expression LE expression .)
    LE              reduce using rule 29 (expression -> expression LE expression .)
    NEQS            reduce using rule 29 (expression -> expression LE expression .)
    OR              reduce using rule 29 (expression -> expression LE expression .)
    NAND            reduce using rule 29 (expression -> expression LE expression .)
    $end            reduce using rule 29 (expression -> expression LE expression .)
    }               reduce using rule 29 (expression -> expression LE expression .)
    ;               reduce using rule 29 (expression -> expression LE expression .)
    THEN            reduce using rule 29 (expression -> expression LE expression .)
    DO              reduce using rule 29 (expression -> expression LE expression .)
    ,               reduce using rule 29 (expression -> expression LE expression .)
    )               reduce using rule 29 (expression -> expression LE expression .)
    ]               reduce using rule 29 (expression -> expression LE expression .)
    LAMBDA          reduce using rule 29 (expression -> expression LE expression .)
    IN              reduce using rule 29 (expression -> expression LE expression .)
    ELSE            reduce using rule 29 (expression -> expression LE expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25

  ! +               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! <               [ shift and go to state 30 ]
  ! GE              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 67

    (30) expression -> expression NEQS expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 30 (expression -> expression NEQS expression .)
    EQ              reduce using rule 30 (expression -> expression NEQS expression .)
    =               reduce using rule 30 (expression -> expression NEQS expression .)
    NEQS            reduce using rule 30 (expression -> expression NEQS expression .)
    OR              reduce using rule 30 (expression -> expression NEQS expression .)
    NAND            reduce using rule 30 (expression -> expression NEQS expression .)
    $end            reduce using rule 30 (expression -> expression NEQS expression .)
    }               reduce using rule 30 (expression -> expression NEQS expression .)
    ;               reduce using rule 30 (expression -> expression NEQS expression .)
    THEN            reduce using rule 30 (expression -> expression NEQS expression .)
    DO              reduce using rule 30 (expression -> expression NEQS expression .)
    ,               reduce using rule 30 (expression -> expression NEQS expression .)
    )               reduce using rule 30 (expression -> expression NEQS expression .)
    ]               reduce using rule 30 (expression -> expression NEQS expression .)
    LAMBDA          reduce using rule 30 (expression -> expression NEQS expression .)
    IN              reduce using rule 30 (expression -> expression NEQS expression .)
    ELSE            reduce using rule 30 (expression -> expression NEQS expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32

  ! +               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! -               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! *               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! /               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! >               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! <               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! GE              [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! LE              [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! =               [ shift and go to state 28 ]
  ! NEQS            [ shift and go to state 33 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 68

    (31) expression -> expression OR expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    OR              reduce using rule 31 (expression -> expression OR expression .)
    $end            reduce using rule 31 (expression -> expression OR expression .)
    }               reduce using rule 31 (expression -> expression OR expression .)
    ;               reduce using rule 31 (expression -> expression OR expression .)
    THEN            reduce using rule 31 (expression -> expression OR expression .)
    DO              reduce using rule 31 (expression -> expression OR expression .)
    ,               reduce using rule 31 (expression -> expression OR expression .)
    )               reduce using rule 31 (expression -> expression OR expression .)
    ]               reduce using rule 31 (expression -> expression OR expression .)
    LAMBDA          reduce using rule 31 (expression -> expression OR expression .)
    IN              reduce using rule 31 (expression -> expression OR expression .)
    ELSE            reduce using rule 31 (expression -> expression OR expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    NAND            shift and go to state 35

  ! +               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! =               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! NEQS            [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! NAND            [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 34 ]


state 69

    (32) expression -> expression NAND expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 32 (expression -> expression NAND expression .)
    OR              reduce using rule 32 (expression -> expression NAND expression .)
    NAND            reduce using rule 32 (expression -> expression NAND expression .)
    $end            reduce using rule 32 (expression -> expression NAND expression .)
    }               reduce using rule 32 (expression -> expression NAND expression .)
    ;               reduce using rule 32 (expression -> expression NAND expression .)
    THEN            reduce using rule 32 (expression -> expression NAND expression .)
    DO              reduce using rule 32 (expression -> expression NAND expression .)
    ,               reduce using rule 32 (expression -> expression NAND expression .)
    )               reduce using rule 32 (expression -> expression NAND expression .)
    ]               reduce using rule 32 (expression -> expression NAND expression .)
    LAMBDA          reduce using rule 32 (expression -> expression NAND expression .)
    IN              reduce using rule 32 (expression -> expression NAND expression .)
    ELSE            reduce using rule 32 (expression -> expression NAND expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33

  ! +               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! -               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! *               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! /               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! EQ              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! =               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! >               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! <               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! GE              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! LE              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! NEQS            [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! AND             [ shift and go to state 26 ]
  ! OR              [ shift and go to state 34 ]
  ! NAND            [ shift and go to state 35 ]


state 70

    (6) expression -> STRUCT { sequence_struct . }
    (17) sequence_struct -> sequence_struct . ; seq_struct_assign_expression

    }               shift and go to state 93
    ;               shift and go to state 94


state 71

    (16) sequence_struct -> seq_struct_assign_expression .

    }               reduce using rule 16 (sequence_struct -> seq_struct_assign_expression .)
    ;               reduce using rule 16 (sequence_struct -> seq_struct_assign_expression .)


state 72

    (53) seq_struct_assign_expression -> . . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    ID              shift and go to state 96

    assign_expression              shift and go to state 95

state 73

    (10) expression -> { sequence } .

    +               reduce using rule 10 (expression -> { sequence } .)
    -               reduce using rule 10 (expression -> { sequence } .)
    *               reduce using rule 10 (expression -> { sequence } .)
    /               reduce using rule 10 (expression -> { sequence } .)
    AND             reduce using rule 10 (expression -> { sequence } .)
    EQ              reduce using rule 10 (expression -> { sequence } .)
    =               reduce using rule 10 (expression -> { sequence } .)
    >               reduce using rule 10 (expression -> { sequence } .)
    <               reduce using rule 10 (expression -> { sequence } .)
    GE              reduce using rule 10 (expression -> { sequence } .)
    LE              reduce using rule 10 (expression -> { sequence } .)
    NEQS            reduce using rule 10 (expression -> { sequence } .)
    OR              reduce using rule 10 (expression -> { sequence } .)
    NAND            reduce using rule 10 (expression -> { sequence } .)
    $end            reduce using rule 10 (expression -> { sequence } .)
    }               reduce using rule 10 (expression -> { sequence } .)
    ;               reduce using rule 10 (expression -> { sequence } .)
    THEN            reduce using rule 10 (expression -> { sequence } .)
    DO              reduce using rule 10 (expression -> { sequence } .)
    ,               reduce using rule 10 (expression -> { sequence } .)
    )               reduce using rule 10 (expression -> { sequence } .)
    ]               reduce using rule 10 (expression -> { sequence } .)
    LAMBDA          reduce using rule 10 (expression -> { sequence } .)
    IN              reduce using rule 10 (expression -> { sequence } .)
    ELSE            reduce using rule 10 (expression -> { sequence } .)


state 74

    (22) sequence -> sequence ; . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 97
    assign_expression              shift and go to state 21

state 75

    (11) expression -> EXTEND ID { . sequence_struct }
    (16) sequence_struct -> . seq_struct_assign_expression
    (17) sequence_struct -> . sequence_struct ; seq_struct_assign_expression
    (53) seq_struct_assign_expression -> . . assign_expression

    .               shift and go to state 72

    sequence_struct                shift and go to state 98
    seq_struct_assign_expression   shift and go to state 71

state 76

    (40) expression -> ID ( ) .

    +               reduce using rule 40 (expression -> ID ( ) .)
    -               reduce using rule 40 (expression -> ID ( ) .)
    *               reduce using rule 40 (expression -> ID ( ) .)
    /               reduce using rule 40 (expression -> ID ( ) .)
    AND             reduce using rule 40 (expression -> ID ( ) .)
    EQ              reduce using rule 40 (expression -> ID ( ) .)
    =               reduce using rule 40 (expression -> ID ( ) .)
    >               reduce using rule 40 (expression -> ID ( ) .)
    <               reduce using rule 40 (expression -> ID ( ) .)
    GE              reduce using rule 40 (expression -> ID ( ) .)
    LE              reduce using rule 40 (expression -> ID ( ) .)
    NEQS            reduce using rule 40 (expression -> ID ( ) .)
    OR              reduce using rule 40 (expression -> ID ( ) .)
    NAND            reduce using rule 40 (expression -> ID ( ) .)
    $end            reduce using rule 40 (expression -> ID ( ) .)
    }               reduce using rule 40 (expression -> ID ( ) .)
    ;               reduce using rule 40 (expression -> ID ( ) .)
    THEN            reduce using rule 40 (expression -> ID ( ) .)
    DO              reduce using rule 40 (expression -> ID ( ) .)
    ,               reduce using rule 40 (expression -> ID ( ) .)
    )               reduce using rule 40 (expression -> ID ( ) .)
    ]               reduce using rule 40 (expression -> ID ( ) .)
    LAMBDA          reduce using rule 40 (expression -> ID ( ) .)
    IN              reduce using rule 40 (expression -> ID ( ) .)
    ELSE            reduce using rule 40 (expression -> ID ( ) .)


state 77

    (41) expression -> ID ( expression_list . )

    )               shift and go to state 99


state 78

    (42) expression -> ID dots ID .
    (44) expression -> ID dots ID . ( )
    (45) expression -> ID dots ID . ( expression_list )

    +               reduce using rule 42 (expression -> ID dots ID .)
    -               reduce using rule 42 (expression -> ID dots ID .)
    *               reduce using rule 42 (expression -> ID dots ID .)
    /               reduce using rule 42 (expression -> ID dots ID .)
    AND             reduce using rule 42 (expression -> ID dots ID .)
    EQ              reduce using rule 42 (expression -> ID dots ID .)
    =               reduce using rule 42 (expression -> ID dots ID .)
    >               reduce using rule 42 (expression -> ID dots ID .)
    <               reduce using rule 42 (expression -> ID dots ID .)
    GE              reduce using rule 42 (expression -> ID dots ID .)
    LE              reduce using rule 42 (expression -> ID dots ID .)
    NEQS            reduce using rule 42 (expression -> ID dots ID .)
    OR              reduce using rule 42 (expression -> ID dots ID .)
    NAND            reduce using rule 42 (expression -> ID dots ID .)
    $end            reduce using rule 42 (expression -> ID dots ID .)
    }               reduce using rule 42 (expression -> ID dots ID .)
    ;               reduce using rule 42 (expression -> ID dots ID .)
    THEN            reduce using rule 42 (expression -> ID dots ID .)
    DO              reduce using rule 42 (expression -> ID dots ID .)
    ,               reduce using rule 42 (expression -> ID dots ID .)
    )               reduce using rule 42 (expression -> ID dots ID .)
    ]               reduce using rule 42 (expression -> ID dots ID .)
    LAMBDA          reduce using rule 42 (expression -> ID dots ID .)
    IN              reduce using rule 42 (expression -> ID dots ID .)
    ELSE            reduce using rule 42 (expression -> ID dots ID .)
    (               shift and go to state 100


state 79

    (47) expression -> ID [ NUMBER . ]

    ]               shift and go to state 101


state 80

    (50) assign_expression -> ID ASSIGN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    }               reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    ;               reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    THEN            reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    DO              reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    ,               reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    )               reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    ]               reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    LAMBDA          reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    IN              reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    ELSE            reduce using rule 50 (assign_expression -> ID ASSIGN expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! -               [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! *               [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! /               [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! AND             [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! EQ              [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! =               [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! >               [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! <               [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! GE              [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! LE              [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! NEQS            [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! OR              [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]
  ! NAND            [ reduce using rule 50 (assign_expression -> ID ASSIGN expression .) ]


state 81

    (51) assign_expression -> ID ASSIGN lambda_expression .

    +               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    -               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    *               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    /               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    AND             reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    EQ              reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    =               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    >               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    <               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    GE              reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    LE              reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    NEQS            reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    OR              reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    NAND            reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    $end            reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    }               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    ;               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    THEN            reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    DO              reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    ,               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    )               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    ]               reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    LAMBDA          reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    IN              reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)
    ELSE            reduce using rule 51 (assign_expression -> ID ASSIGN lambda_expression .)


state 82

    (54) lambda_expression -> LAMBDA_START . expression_list LAMBDA seq_struct_assign_expression
    (55) lambda_expression -> LAMBDA_START . LAMBDA seq_struct_assign_expression
    (56) lambda_expression -> LAMBDA_START . LAMBDA expression
    (57) lambda_expression -> LAMBDA_START . expression_list LAMBDA expression
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    LAMBDA          shift and go to state 103
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression_list                shift and go to state 102
    expression                     shift and go to state 52
    assign_expression              shift and go to state 21

state 83

    (35) dots -> . dots .

    ID              reduce using rule 35 (dots -> . dots .)


state 84

    (12) expression -> LOCAL ID ASSIGN . expression IN expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 104
    assign_expression              shift and go to state 21

state 85

    (14) expression -> IF expression THEN . expression
    (19) expression -> IF expression THEN . expression ELSE expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 105
    assign_expression              shift and go to state 21

state 86

    (15) expression -> IMPORT ID AS . ID

    ID              shift and go to state 106


state 87

    (36) expression -> LOOP expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 107
    assign_expression              shift and go to state 21

state 88

    (38) expression -> FOR expression ; . expression ; expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 108
    assign_expression              shift and go to state 21

state 89

    (48) expression -> ( expression_list ) .

    +               reduce using rule 48 (expression -> ( expression_list ) .)
    -               reduce using rule 48 (expression -> ( expression_list ) .)
    *               reduce using rule 48 (expression -> ( expression_list ) .)
    /               reduce using rule 48 (expression -> ( expression_list ) .)
    AND             reduce using rule 48 (expression -> ( expression_list ) .)
    EQ              reduce using rule 48 (expression -> ( expression_list ) .)
    =               reduce using rule 48 (expression -> ( expression_list ) .)
    >               reduce using rule 48 (expression -> ( expression_list ) .)
    <               reduce using rule 48 (expression -> ( expression_list ) .)
    GE              reduce using rule 48 (expression -> ( expression_list ) .)
    LE              reduce using rule 48 (expression -> ( expression_list ) .)
    NEQS            reduce using rule 48 (expression -> ( expression_list ) .)
    OR              reduce using rule 48 (expression -> ( expression_list ) .)
    NAND            reduce using rule 48 (expression -> ( expression_list ) .)
    $end            reduce using rule 48 (expression -> ( expression_list ) .)
    }               reduce using rule 48 (expression -> ( expression_list ) .)
    ;               reduce using rule 48 (expression -> ( expression_list ) .)
    THEN            reduce using rule 48 (expression -> ( expression_list ) .)
    DO              reduce using rule 48 (expression -> ( expression_list ) .)
    ,               reduce using rule 48 (expression -> ( expression_list ) .)
    )               reduce using rule 48 (expression -> ( expression_list ) .)
    ]               reduce using rule 48 (expression -> ( expression_list ) .)
    LAMBDA          reduce using rule 48 (expression -> ( expression_list ) .)
    IN              reduce using rule 48 (expression -> ( expression_list ) .)
    ELSE            reduce using rule 48 (expression -> ( expression_list ) .)


state 90

    (7) expression_list -> expression , . expression_list
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 52
    expression_list                shift and go to state 109
    assign_expression              shift and go to state 21

state 91

    (43) expression -> WHILE expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 110
    assign_expression              shift and go to state 21

state 92

    (46) expression -> [ expression_list ] .

    +               reduce using rule 46 (expression -> [ expression_list ] .)
    -               reduce using rule 46 (expression -> [ expression_list ] .)
    *               reduce using rule 46 (expression -> [ expression_list ] .)
    /               reduce using rule 46 (expression -> [ expression_list ] .)
    AND             reduce using rule 46 (expression -> [ expression_list ] .)
    EQ              reduce using rule 46 (expression -> [ expression_list ] .)
    =               reduce using rule 46 (expression -> [ expression_list ] .)
    >               reduce using rule 46 (expression -> [ expression_list ] .)
    <               reduce using rule 46 (expression -> [ expression_list ] .)
    GE              reduce using rule 46 (expression -> [ expression_list ] .)
    LE              reduce using rule 46 (expression -> [ expression_list ] .)
    NEQS            reduce using rule 46 (expression -> [ expression_list ] .)
    OR              reduce using rule 46 (expression -> [ expression_list ] .)
    NAND            reduce using rule 46 (expression -> [ expression_list ] .)
    $end            reduce using rule 46 (expression -> [ expression_list ] .)
    }               reduce using rule 46 (expression -> [ expression_list ] .)
    ;               reduce using rule 46 (expression -> [ expression_list ] .)
    THEN            reduce using rule 46 (expression -> [ expression_list ] .)
    DO              reduce using rule 46 (expression -> [ expression_list ] .)
    ,               reduce using rule 46 (expression -> [ expression_list ] .)
    )               reduce using rule 46 (expression -> [ expression_list ] .)
    ]               reduce using rule 46 (expression -> [ expression_list ] .)
    LAMBDA          reduce using rule 46 (expression -> [ expression_list ] .)
    IN              reduce using rule 46 (expression -> [ expression_list ] .)
    ELSE            reduce using rule 46 (expression -> [ expression_list ] .)


state 93

    (6) expression -> STRUCT { sequence_struct } .

    +               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    -               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    *               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    /               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    AND             reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    EQ              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    =               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    >               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    <               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    GE              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    LE              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    NEQS            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    OR              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    NAND            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    $end            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    }               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ;               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    THEN            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    DO              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ,               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    )               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ]               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    LAMBDA          reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    IN              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ELSE            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)


state 94

    (17) sequence_struct -> sequence_struct ; . seq_struct_assign_expression
    (53) seq_struct_assign_expression -> . . assign_expression

    .               shift and go to state 72

    seq_struct_assign_expression   shift and go to state 111

state 95

    (53) seq_struct_assign_expression -> . assign_expression .

    }               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    ;               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    +               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    -               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    *               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    /               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    AND             reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    EQ              reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    =               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    >               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    <               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    GE              reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    LE              reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    NEQS            reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    OR              reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    NAND            reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    $end            reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    THEN            reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    DO              reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    ,               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    )               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    ]               reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    LAMBDA          reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    IN              reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)
    ELSE            reduce using rule 53 (seq_struct_assign_expression -> . assign_expression .)


state 96

    (50) assign_expression -> ID . ASSIGN expression
    (51) assign_expression -> ID . ASSIGN lambda_expression

    ASSIGN          shift and go to state 44


state 97

    (22) sequence -> sequence ; expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 22 (sequence -> sequence ; expression .)
    ;               reduce using rule 22 (sequence -> sequence ; expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 98

    (11) expression -> EXTEND ID { sequence_struct . }
    (17) sequence_struct -> sequence_struct . ; seq_struct_assign_expression

    }               shift and go to state 112
    ;               shift and go to state 94


state 99

    (41) expression -> ID ( expression_list ) .

    +               reduce using rule 41 (expression -> ID ( expression_list ) .)
    -               reduce using rule 41 (expression -> ID ( expression_list ) .)
    *               reduce using rule 41 (expression -> ID ( expression_list ) .)
    /               reduce using rule 41 (expression -> ID ( expression_list ) .)
    AND             reduce using rule 41 (expression -> ID ( expression_list ) .)
    EQ              reduce using rule 41 (expression -> ID ( expression_list ) .)
    =               reduce using rule 41 (expression -> ID ( expression_list ) .)
    >               reduce using rule 41 (expression -> ID ( expression_list ) .)
    <               reduce using rule 41 (expression -> ID ( expression_list ) .)
    GE              reduce using rule 41 (expression -> ID ( expression_list ) .)
    LE              reduce using rule 41 (expression -> ID ( expression_list ) .)
    NEQS            reduce using rule 41 (expression -> ID ( expression_list ) .)
    OR              reduce using rule 41 (expression -> ID ( expression_list ) .)
    NAND            reduce using rule 41 (expression -> ID ( expression_list ) .)
    $end            reduce using rule 41 (expression -> ID ( expression_list ) .)
    }               reduce using rule 41 (expression -> ID ( expression_list ) .)
    ;               reduce using rule 41 (expression -> ID ( expression_list ) .)
    THEN            reduce using rule 41 (expression -> ID ( expression_list ) .)
    DO              reduce using rule 41 (expression -> ID ( expression_list ) .)
    ,               reduce using rule 41 (expression -> ID ( expression_list ) .)
    )               reduce using rule 41 (expression -> ID ( expression_list ) .)
    ]               reduce using rule 41 (expression -> ID ( expression_list ) .)
    LAMBDA          reduce using rule 41 (expression -> ID ( expression_list ) .)
    IN              reduce using rule 41 (expression -> ID ( expression_list ) .)
    ELSE            reduce using rule 41 (expression -> ID ( expression_list ) .)


state 100

    (44) expression -> ID dots ID ( . )
    (45) expression -> ID dots ID ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    )               shift and go to state 113
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression_list                shift and go to state 114
    expression                     shift and go to state 52
    assign_expression              shift and go to state 21

state 101

    (47) expression -> ID [ NUMBER ] .

    +               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    -               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    *               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    /               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    AND             reduce using rule 47 (expression -> ID [ NUMBER ] .)
    EQ              reduce using rule 47 (expression -> ID [ NUMBER ] .)
    =               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    >               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    <               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    GE              reduce using rule 47 (expression -> ID [ NUMBER ] .)
    LE              reduce using rule 47 (expression -> ID [ NUMBER ] .)
    NEQS            reduce using rule 47 (expression -> ID [ NUMBER ] .)
    OR              reduce using rule 47 (expression -> ID [ NUMBER ] .)
    NAND            reduce using rule 47 (expression -> ID [ NUMBER ] .)
    $end            reduce using rule 47 (expression -> ID [ NUMBER ] .)
    }               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    ;               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    THEN            reduce using rule 47 (expression -> ID [ NUMBER ] .)
    DO              reduce using rule 47 (expression -> ID [ NUMBER ] .)
    ,               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    )               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    ]               reduce using rule 47 (expression -> ID [ NUMBER ] .)
    LAMBDA          reduce using rule 47 (expression -> ID [ NUMBER ] .)
    IN              reduce using rule 47 (expression -> ID [ NUMBER ] .)
    ELSE            reduce using rule 47 (expression -> ID [ NUMBER ] .)


state 102

    (54) lambda_expression -> LAMBDA_START expression_list . LAMBDA seq_struct_assign_expression
    (57) lambda_expression -> LAMBDA_START expression_list . LAMBDA expression

    LAMBDA          shift and go to state 115


state 103

    (55) lambda_expression -> LAMBDA_START LAMBDA . seq_struct_assign_expression
    (56) lambda_expression -> LAMBDA_START LAMBDA . expression
    (53) seq_struct_assign_expression -> . . assign_expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    .               shift and go to state 72
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    seq_struct_assign_expression   shift and go to state 116
    expression                     shift and go to state 117
    assign_expression              shift and go to state 21

state 104

    (12) expression -> LOCAL ID ASSIGN expression . IN expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    IN              shift and go to state 118
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 105

    (14) expression -> IF expression THEN expression .
    (19) expression -> IF expression THEN expression . ELSE expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 14 (expression -> IF expression THEN expression .)
    }               reduce using rule 14 (expression -> IF expression THEN expression .)
    ;               reduce using rule 14 (expression -> IF expression THEN expression .)
    THEN            reduce using rule 14 (expression -> IF expression THEN expression .)
    DO              reduce using rule 14 (expression -> IF expression THEN expression .)
    ,               reduce using rule 14 (expression -> IF expression THEN expression .)
    )               reduce using rule 14 (expression -> IF expression THEN expression .)
    ]               reduce using rule 14 (expression -> IF expression THEN expression .)
    LAMBDA          reduce using rule 14 (expression -> IF expression THEN expression .)
    IN              reduce using rule 14 (expression -> IF expression THEN expression .)
    ELSE            shift and go to state 119
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! -               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! *               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! /               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! AND             [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! EQ              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! =               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! >               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! <               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! GE              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! LE              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! NEQS            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! OR              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! NAND            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! ELSE            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]


state 106

    (15) expression -> IMPORT ID AS ID .

    +               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    -               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    *               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    /               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    AND             reduce using rule 15 (expression -> IMPORT ID AS ID .)
    EQ              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    =               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    >               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    <               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    GE              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    LE              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    NEQS            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    OR              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    NAND            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    $end            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    }               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ;               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    THEN            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    DO              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ,               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    )               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ]               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    LAMBDA          reduce using rule 15 (expression -> IMPORT ID AS ID .)
    IN              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ELSE            reduce using rule 15 (expression -> IMPORT ID AS ID .)


state 107

    (36) expression -> LOOP expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 36 (expression -> LOOP expression DO expression .)
    }               reduce using rule 36 (expression -> LOOP expression DO expression .)
    ;               reduce using rule 36 (expression -> LOOP expression DO expression .)
    THEN            reduce using rule 36 (expression -> LOOP expression DO expression .)
    DO              reduce using rule 36 (expression -> LOOP expression DO expression .)
    ,               reduce using rule 36 (expression -> LOOP expression DO expression .)
    )               reduce using rule 36 (expression -> LOOP expression DO expression .)
    ]               reduce using rule 36 (expression -> LOOP expression DO expression .)
    LAMBDA          reduce using rule 36 (expression -> LOOP expression DO expression .)
    IN              reduce using rule 36 (expression -> LOOP expression DO expression .)
    ELSE            reduce using rule 36 (expression -> LOOP expression DO expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! -               [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! *               [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! /               [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! AND             [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! EQ              [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! =               [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! >               [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! <               [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! GE              [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! LE              [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! NEQS            [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! OR              [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]
  ! NAND            [ reduce using rule 36 (expression -> LOOP expression DO expression .) ]


state 108

    (38) expression -> FOR expression ; expression . ; expression DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ;               shift and go to state 120
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 109

    (7) expression_list -> expression , expression_list .

    )               reduce using rule 7 (expression_list -> expression , expression_list .)
    ]               reduce using rule 7 (expression_list -> expression , expression_list .)
    LAMBDA          reduce using rule 7 (expression_list -> expression , expression_list .)


state 110

    (43) expression -> WHILE expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 43 (expression -> WHILE expression DO expression .)
    }               reduce using rule 43 (expression -> WHILE expression DO expression .)
    ;               reduce using rule 43 (expression -> WHILE expression DO expression .)
    THEN            reduce using rule 43 (expression -> WHILE expression DO expression .)
    DO              reduce using rule 43 (expression -> WHILE expression DO expression .)
    ,               reduce using rule 43 (expression -> WHILE expression DO expression .)
    )               reduce using rule 43 (expression -> WHILE expression DO expression .)
    ]               reduce using rule 43 (expression -> WHILE expression DO expression .)
    LAMBDA          reduce using rule 43 (expression -> WHILE expression DO expression .)
    IN              reduce using rule 43 (expression -> WHILE expression DO expression .)
    ELSE            reduce using rule 43 (expression -> WHILE expression DO expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! -               [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! *               [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! /               [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! AND             [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! EQ              [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! =               [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! >               [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! <               [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! GE              [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! LE              [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! NEQS            [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! OR              [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]
  ! NAND            [ reduce using rule 43 (expression -> WHILE expression DO expression .) ]


state 111

    (17) sequence_struct -> sequence_struct ; seq_struct_assign_expression .

    }               reduce using rule 17 (sequence_struct -> sequence_struct ; seq_struct_assign_expression .)
    ;               reduce using rule 17 (sequence_struct -> sequence_struct ; seq_struct_assign_expression .)


state 112

    (11) expression -> EXTEND ID { sequence_struct } .

    +               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    -               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    *               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    /               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    AND             reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    EQ              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    =               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    >               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    <               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    GE              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    LE              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    NEQS            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    OR              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    NAND            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    $end            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    }               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ;               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    THEN            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    DO              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ,               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    )               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ]               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    LAMBDA          reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    IN              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ELSE            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)


state 113

    (44) expression -> ID dots ID ( ) .

    +               reduce using rule 44 (expression -> ID dots ID ( ) .)
    -               reduce using rule 44 (expression -> ID dots ID ( ) .)
    *               reduce using rule 44 (expression -> ID dots ID ( ) .)
    /               reduce using rule 44 (expression -> ID dots ID ( ) .)
    AND             reduce using rule 44 (expression -> ID dots ID ( ) .)
    EQ              reduce using rule 44 (expression -> ID dots ID ( ) .)
    =               reduce using rule 44 (expression -> ID dots ID ( ) .)
    >               reduce using rule 44 (expression -> ID dots ID ( ) .)
    <               reduce using rule 44 (expression -> ID dots ID ( ) .)
    GE              reduce using rule 44 (expression -> ID dots ID ( ) .)
    LE              reduce using rule 44 (expression -> ID dots ID ( ) .)
    NEQS            reduce using rule 44 (expression -> ID dots ID ( ) .)
    OR              reduce using rule 44 (expression -> ID dots ID ( ) .)
    NAND            reduce using rule 44 (expression -> ID dots ID ( ) .)
    $end            reduce using rule 44 (expression -> ID dots ID ( ) .)
    }               reduce using rule 44 (expression -> ID dots ID ( ) .)
    ;               reduce using rule 44 (expression -> ID dots ID ( ) .)
    THEN            reduce using rule 44 (expression -> ID dots ID ( ) .)
    DO              reduce using rule 44 (expression -> ID dots ID ( ) .)
    ,               reduce using rule 44 (expression -> ID dots ID ( ) .)
    )               reduce using rule 44 (expression -> ID dots ID ( ) .)
    ]               reduce using rule 44 (expression -> ID dots ID ( ) .)
    LAMBDA          reduce using rule 44 (expression -> ID dots ID ( ) .)
    IN              reduce using rule 44 (expression -> ID dots ID ( ) .)
    ELSE            reduce using rule 44 (expression -> ID dots ID ( ) .)


state 114

    (45) expression -> ID dots ID ( expression_list . )

    )               shift and go to state 121


state 115

    (54) lambda_expression -> LAMBDA_START expression_list LAMBDA . seq_struct_assign_expression
    (57) lambda_expression -> LAMBDA_START expression_list LAMBDA . expression
    (53) seq_struct_assign_expression -> . . assign_expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    .               shift and go to state 72
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    seq_struct_assign_expression   shift and go to state 122
    expression                     shift and go to state 123
    assign_expression              shift and go to state 21

state 116

    (55) lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .

    +               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    -               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    *               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    /               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    AND             reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    EQ              reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    =               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    >               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    <               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    GE              reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    LE              reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    NEQS            reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    OR              reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    NAND            reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    $end            reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    }               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    ;               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    THEN            reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    DO              reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    ,               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    )               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    ]               reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    LAMBDA          reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    IN              reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)
    ELSE            reduce using rule 55 (lambda_expression -> LAMBDA_START LAMBDA seq_struct_assign_expression .)


state 117

    (56) lambda_expression -> LAMBDA_START LAMBDA expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    }               reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    ;               reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    THEN            reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    DO              reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    ,               reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    )               reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    ]               reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    LAMBDA          reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    IN              reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    ELSE            reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! -               [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! *               [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! /               [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! AND             [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! EQ              [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! =               [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! >               [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! <               [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! GE              [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! LE              [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! NEQS            [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! OR              [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]
  ! NAND            [ reduce using rule 56 (lambda_expression -> LAMBDA_START LAMBDA expression .) ]


state 118

    (12) expression -> LOCAL ID ASSIGN expression IN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 124
    assign_expression              shift and go to state 21

state 119

    (19) expression -> IF expression THEN expression ELSE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 125
    assign_expression              shift and go to state 21

state 120

    (38) expression -> FOR expression ; expression ; . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 126
    assign_expression              shift and go to state 21

state 121

    (45) expression -> ID dots ID ( expression_list ) .

    +               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    -               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    *               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    /               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    AND             reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    EQ              reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    =               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    >               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    <               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    GE              reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    LE              reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    NEQS            reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    OR              reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    NAND            reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    $end            reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    }               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    ;               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    THEN            reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    DO              reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    ,               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    )               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    ]               reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    LAMBDA          reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    IN              reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)
    ELSE            reduce using rule 45 (expression -> ID dots ID ( expression_list ) .)


state 122

    (54) lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .

    +               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    -               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    *               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    /               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    AND             reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    EQ              reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    =               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    >               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    <               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    GE              reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    LE              reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    NEQS            reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    OR              reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    NAND            reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    $end            reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    }               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    ;               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    THEN            reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    DO              reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    ,               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    )               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    ]               reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    LAMBDA          reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    IN              reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)
    ELSE            reduce using rule 54 (lambda_expression -> LAMBDA_START expression_list LAMBDA seq_struct_assign_expression .)


state 123

    (57) lambda_expression -> LAMBDA_START expression_list LAMBDA expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    }               reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    ;               reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    THEN            reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    DO              reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    ,               reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    )               reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    ]               reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    LAMBDA          reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    IN              reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    ELSE            reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! -               [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! *               [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! /               [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! AND             [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! EQ              [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! =               [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! >               [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! <               [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! GE              [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! LE              [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! NEQS            [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! OR              [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! NAND            [ reduce using rule 57 (lambda_expression -> LAMBDA_START expression_list LAMBDA expression .) ]


state 124

    (12) expression -> LOCAL ID ASSIGN expression IN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for = resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NEQS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NAND resolved as shift
    $end            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    }               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ;               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    THEN            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    DO              reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ,               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    )               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ]               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    LAMBDA          reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    IN              reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ELSE            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! -               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! *               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! /               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! AND             [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! EQ              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! =               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! >               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! <               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! GE              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! LE              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! NEQS            [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! OR              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! NAND            [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]


state 125

    (19) expression -> IF expression THEN expression ELSE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    }               reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    ;               reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    THEN            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    DO              reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    ,               reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    )               reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    ]               reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    LAMBDA          reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    IN              reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    ELSE            reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! -               [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! *               [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! /               [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! AND             [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! EQ              [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! =               [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! >               [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! <               [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! GE              [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! LE              [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! NEQS            [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! OR              [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]
  ! NAND            [ reduce using rule 19 (expression -> IF expression THEN expression ELSE expression .) ]


state 126

    (38) expression -> FOR expression ; expression ; expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 127
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35


state 127

    (38) expression -> FOR expression ; expression ; expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (18) expression -> . FLOAT
    (19) expression -> . IF expression THEN expression ELSE expression
    (20) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . STRING
    (36) expression -> . LOOP expression DO expression
    (37) expression -> . CHAR
    (38) expression -> . FOR expression ; expression ; expression DO expression
    (39) expression -> . ID
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID dots ID
    (43) expression -> . WHILE expression DO expression
    (44) expression -> . ID dots ID ( )
    (45) expression -> . ID dots ID ( expression_list )
    (46) expression -> . [ expression_list ]
    (47) expression -> . ID [ NUMBER ]
    (48) expression -> . ( expression_list )
    (49) expression -> . NOT expression
    (52) expression -> . assign_expression
    (50) assign_expression -> . ID ASSIGN expression
    (51) assign_expression -> . ID ASSIGN lambda_expression

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    LOOP            shift and go to state 14
    CHAR            shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 7
    WHILE           shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 17
    NOT             shift and go to state 20

    expression                     shift and go to state 128
    assign_expression              shift and go to state 21

state 128

    (38) expression -> FOR expression ; expression ; expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    }               reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    ;               reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    THEN            reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    DO              reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    ,               reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    )               reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    ]               reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    LAMBDA          reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    IN              reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    ELSE            reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .)
    +               shift and go to state 22
    -               shift and go to state 23
    *               shift and go to state 24
    /               shift and go to state 25
    AND             shift and go to state 26
    EQ              shift and go to state 27
    =               shift and go to state 28
    >               shift and go to state 29
    <               shift and go to state 30
    GE              shift and go to state 31
    LE              shift and go to state 32
    NEQS            shift and go to state 33
    OR              shift and go to state 34
    NAND            shift and go to state 35

  ! +               [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! -               [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! *               [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! /               [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! AND             [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! EQ              [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! =               [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! >               [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! <               [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! GE              [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! LE              [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! NEQS            [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! OR              [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! NAND            [ reduce using rule 38 (expression -> FOR expression ; expression ; expression DO expression .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 124 resolved as shift
WARNING: shift/reduce conflict for - in state 124 resolved as shift
WARNING: shift/reduce conflict for * in state 124 resolved as shift
WARNING: shift/reduce conflict for / in state 124 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for = in state 124 resolved as shift
WARNING: shift/reduce conflict for > in state 124 resolved as shift
WARNING: shift/reduce conflict for < in state 124 resolved as shift
WARNING: shift/reduce conflict for GE in state 124 resolved as shift
WARNING: shift/reduce conflict for LE in state 124 resolved as shift
WARNING: shift/reduce conflict for NEQS in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
WARNING: shift/reduce conflict for NAND in state 124 resolved as shift
