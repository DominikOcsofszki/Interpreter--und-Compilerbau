Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> expression
Rule 1     expression -> - expression
Rule 2     expression -> expression + expression
Rule 3     expression -> expression - expression
Rule 4     expression -> expression * expression
Rule 5     expression -> expression / expression
Rule 6     expression -> STRUCT { sequence_struct }
Rule 7     expression_list -> expression , expression_list
Rule 8     expression_list -> expression
Rule 9     expression -> NUMBER
Rule 10    expression -> { sequence }
Rule 11    expression -> EXTEND ID { sequence_struct }
Rule 12    expression -> LOCAL ID ASSIGN expression IN expression
Rule 13    expression -> BOOL
Rule 14    expression -> IF expression THEN expression
Rule 15    expression -> IMPORT ID AS ID
Rule 16    dots -> .
Rule 17    dots -> . dots
Rule 18    sequence -> expression
Rule 19    sequence -> sequence ; expression
Rule 20    expression -> FLOAT
Rule 21    expression -> IF expression THEN expression ELSE expression
Rule 22    expression -> IMPORT ID
Rule 23    expression -> expression AND expression
Rule 24    expression -> expression EQ expression
Rule 25    expression -> expression = expression
Rule 26    expression -> expression > expression
Rule 27    expression -> expression < expression
Rule 28    expression -> expression GE expression
Rule 29    expression -> expression LE expression
Rule 30    expression -> expression NEQS expression
Rule 31    expression -> expression OR expression
Rule 32    expression -> expression NAND expression
Rule 33    expression -> LAMBDA_START LAMBDA expression
Rule 34    expression -> LAMBDA_START expression_list LAMBDA expression
Rule 35    expression -> STRING
Rule 36    expression -> ID dots ID
Rule 37    expression -> LOOP expression DO expression
Rule 38    expression -> CHAR
Rule 39    expression -> FOR expression ; expression ; expression DO expression
Rule 40    expression -> ID ( )
Rule 41    expression -> ID ( expression_list )
Rule 42    expression -> ID
Rule 43    expression -> ID dots ID ( )
Rule 44    expression -> ID dots ID ( expression_list )
Rule 45    expression -> WHILE expression DO expression
Rule 46    dots_in_struct_expression -> dots ID
Rule 47    expression -> [ expression_list ]
Rule 48    expression -> dots_in_struct_expression ( )
Rule 49    expression -> dots_in_struct_expression ( expression_list )
Rule 50    expression -> ID [ NUMBER ]
Rule 51    expression -> ( expression_list )
Rule 52    expression -> NOT expression
Rule 53    expression -> ID ASSIGN expression
Rule 54    expression -> dots ID ASSIGN expression
Rule 55    seq_assign_expression -> dots ID ASSIGN expression
Rule 56    sequence_struct -> seq_assign_expression
Rule 57    sequence_struct -> sequence_struct ; seq_assign_expression

Terminals, with rules where they appear

(                    : 40 41 43 44 48 49 51
)                    : 40 41 43 44 48 49 51
*                    : 4
+                    : 2
,                    : 7
-                    : 1 3
.                    : 16 17
/                    : 5
;                    : 19 39 39 57
<                    : 27
=                    : 25
>                    : 26
AND                  : 23
AS                   : 15
ASSIGN               : 12 53 54 55
BOOL                 : 13
CHAR                 : 38
DO                   : 37 39 45
ELSE                 : 21
EQ                   : 24
EXTEND               : 11
FLOAT                : 20
FOR                  : 39
GE                   : 28
ID                   : 11 12 15 15 22 36 36 40 41 42 43 43 44 44 46 50 53 54 55
IF                   : 14 21
IMPORT               : 15 22
IN                   : 12
LAMBDA               : 33 34
LAMBDA_START         : 33 34
LE                   : 29
LOCAL                : 12
LOOP                 : 37
NAND                 : 32
NEQS                 : 30
NOT                  : 52
NUMBER               : 9 50
OR                   : 31
STRING               : 35
STRUCT               : 6
THEN                 : 14 21
WHILE                : 45
[                    : 47 50
]                    : 47 50
error                : 
{                    : 6 10 11
}                    : 6 10 11

Nonterminals, with rules where they appear

dots                 : 17 36 43 44 46 54 55
dots_in_struct_expression : 48 49
expression           : 1 2 2 3 3 4 4 5 5 7 8 12 12 14 14 18 19 21 21 21 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 34 37 37 39 39 39 39 45 45 52 53 54 55 0
expression_list      : 7 34 41 44 47 49 51
seq_assign_expression : 56 57
sequence             : 10 19
sequence_struct      : 6 11 57

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 1
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 1

    (0) S' -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 2

    (1) expression -> - . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 39
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 3

    (6) expression -> STRUCT . { sequence_struct }

    {               shift and go to state 40


state 4

    (10) expression -> { . sequence }
    (18) sequence -> . expression
    (19) sequence -> . sequence ; expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    sequence                       shift and go to state 41
    expression                     shift and go to state 42
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 5

    (9) expression -> NUMBER .

    +               reduce using rule 9 (expression -> NUMBER .)
    -               reduce using rule 9 (expression -> NUMBER .)
    *               reduce using rule 9 (expression -> NUMBER .)
    /               reduce using rule 9 (expression -> NUMBER .)
    AND             reduce using rule 9 (expression -> NUMBER .)
    EQ              reduce using rule 9 (expression -> NUMBER .)
    =               reduce using rule 9 (expression -> NUMBER .)
    >               reduce using rule 9 (expression -> NUMBER .)
    <               reduce using rule 9 (expression -> NUMBER .)
    GE              reduce using rule 9 (expression -> NUMBER .)
    LE              reduce using rule 9 (expression -> NUMBER .)
    NEQS            reduce using rule 9 (expression -> NUMBER .)
    OR              reduce using rule 9 (expression -> NUMBER .)
    NAND            reduce using rule 9 (expression -> NUMBER .)
    $end            reduce using rule 9 (expression -> NUMBER .)
    }               reduce using rule 9 (expression -> NUMBER .)
    ;               reduce using rule 9 (expression -> NUMBER .)
    THEN            reduce using rule 9 (expression -> NUMBER .)
    ,               reduce using rule 9 (expression -> NUMBER .)
    LAMBDA          reduce using rule 9 (expression -> NUMBER .)
    DO              reduce using rule 9 (expression -> NUMBER .)
    )               reduce using rule 9 (expression -> NUMBER .)
    ]               reduce using rule 9 (expression -> NUMBER .)
    IN              reduce using rule 9 (expression -> NUMBER .)
    ELSE            reduce using rule 9 (expression -> NUMBER .)


state 6

    (11) expression -> EXTEND . ID { sequence_struct }

    ID              shift and go to state 43


state 7

    (36) expression -> ID . dots ID
    (40) expression -> ID . ( )
    (41) expression -> ID . ( expression_list )
    (42) expression -> ID .
    (43) expression -> ID . dots ID ( )
    (44) expression -> ID . dots ID ( expression_list )
    (50) expression -> ID . [ NUMBER ]
    (53) expression -> ID . ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    (               shift and go to state 45
    +               reduce using rule 42 (expression -> ID .)
    -               reduce using rule 42 (expression -> ID .)
    *               reduce using rule 42 (expression -> ID .)
    /               reduce using rule 42 (expression -> ID .)
    AND             reduce using rule 42 (expression -> ID .)
    EQ              reduce using rule 42 (expression -> ID .)
    =               reduce using rule 42 (expression -> ID .)
    >               reduce using rule 42 (expression -> ID .)
    <               reduce using rule 42 (expression -> ID .)
    GE              reduce using rule 42 (expression -> ID .)
    LE              reduce using rule 42 (expression -> ID .)
    NEQS            reduce using rule 42 (expression -> ID .)
    OR              reduce using rule 42 (expression -> ID .)
    NAND            reduce using rule 42 (expression -> ID .)
    $end            reduce using rule 42 (expression -> ID .)
    }               reduce using rule 42 (expression -> ID .)
    ;               reduce using rule 42 (expression -> ID .)
    THEN            reduce using rule 42 (expression -> ID .)
    ,               reduce using rule 42 (expression -> ID .)
    LAMBDA          reduce using rule 42 (expression -> ID .)
    DO              reduce using rule 42 (expression -> ID .)
    )               reduce using rule 42 (expression -> ID .)
    ]               reduce using rule 42 (expression -> ID .)
    IN              reduce using rule 42 (expression -> ID .)
    ELSE            reduce using rule 42 (expression -> ID .)
    [               shift and go to state 46
    ASSIGN          shift and go to state 47
    .               shift and go to state 24

    dots                           shift and go to state 44

state 8

    (12) expression -> LOCAL . ID ASSIGN expression IN expression

    ID              shift and go to state 48


state 9

    (13) expression -> BOOL .

    +               reduce using rule 13 (expression -> BOOL .)
    -               reduce using rule 13 (expression -> BOOL .)
    *               reduce using rule 13 (expression -> BOOL .)
    /               reduce using rule 13 (expression -> BOOL .)
    AND             reduce using rule 13 (expression -> BOOL .)
    EQ              reduce using rule 13 (expression -> BOOL .)
    =               reduce using rule 13 (expression -> BOOL .)
    >               reduce using rule 13 (expression -> BOOL .)
    <               reduce using rule 13 (expression -> BOOL .)
    GE              reduce using rule 13 (expression -> BOOL .)
    LE              reduce using rule 13 (expression -> BOOL .)
    NEQS            reduce using rule 13 (expression -> BOOL .)
    OR              reduce using rule 13 (expression -> BOOL .)
    NAND            reduce using rule 13 (expression -> BOOL .)
    $end            reduce using rule 13 (expression -> BOOL .)
    }               reduce using rule 13 (expression -> BOOL .)
    ;               reduce using rule 13 (expression -> BOOL .)
    THEN            reduce using rule 13 (expression -> BOOL .)
    ,               reduce using rule 13 (expression -> BOOL .)
    LAMBDA          reduce using rule 13 (expression -> BOOL .)
    DO              reduce using rule 13 (expression -> BOOL .)
    )               reduce using rule 13 (expression -> BOOL .)
    ]               reduce using rule 13 (expression -> BOOL .)
    IN              reduce using rule 13 (expression -> BOOL .)
    ELSE            reduce using rule 13 (expression -> BOOL .)


state 10

    (14) expression -> IF . expression THEN expression
    (21) expression -> IF . expression THEN expression ELSE expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 49
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 11

    (15) expression -> IMPORT . ID AS ID
    (22) expression -> IMPORT . ID

    ID              shift and go to state 50


state 12

    (20) expression -> FLOAT .

    +               reduce using rule 20 (expression -> FLOAT .)
    -               reduce using rule 20 (expression -> FLOAT .)
    *               reduce using rule 20 (expression -> FLOAT .)
    /               reduce using rule 20 (expression -> FLOAT .)
    AND             reduce using rule 20 (expression -> FLOAT .)
    EQ              reduce using rule 20 (expression -> FLOAT .)
    =               reduce using rule 20 (expression -> FLOAT .)
    >               reduce using rule 20 (expression -> FLOAT .)
    <               reduce using rule 20 (expression -> FLOAT .)
    GE              reduce using rule 20 (expression -> FLOAT .)
    LE              reduce using rule 20 (expression -> FLOAT .)
    NEQS            reduce using rule 20 (expression -> FLOAT .)
    OR              reduce using rule 20 (expression -> FLOAT .)
    NAND            reduce using rule 20 (expression -> FLOAT .)
    $end            reduce using rule 20 (expression -> FLOAT .)
    }               reduce using rule 20 (expression -> FLOAT .)
    ;               reduce using rule 20 (expression -> FLOAT .)
    THEN            reduce using rule 20 (expression -> FLOAT .)
    ,               reduce using rule 20 (expression -> FLOAT .)
    LAMBDA          reduce using rule 20 (expression -> FLOAT .)
    DO              reduce using rule 20 (expression -> FLOAT .)
    )               reduce using rule 20 (expression -> FLOAT .)
    ]               reduce using rule 20 (expression -> FLOAT .)
    IN              reduce using rule 20 (expression -> FLOAT .)
    ELSE            reduce using rule 20 (expression -> FLOAT .)


state 13

    (33) expression -> LAMBDA_START . LAMBDA expression
    (34) expression -> LAMBDA_START . expression_list LAMBDA expression
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    LAMBDA          shift and go to state 51
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 52
    expression_list                shift and go to state 53
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 14

    (35) expression -> STRING .

    +               reduce using rule 35 (expression -> STRING .)
    -               reduce using rule 35 (expression -> STRING .)
    *               reduce using rule 35 (expression -> STRING .)
    /               reduce using rule 35 (expression -> STRING .)
    AND             reduce using rule 35 (expression -> STRING .)
    EQ              reduce using rule 35 (expression -> STRING .)
    =               reduce using rule 35 (expression -> STRING .)
    >               reduce using rule 35 (expression -> STRING .)
    <               reduce using rule 35 (expression -> STRING .)
    GE              reduce using rule 35 (expression -> STRING .)
    LE              reduce using rule 35 (expression -> STRING .)
    NEQS            reduce using rule 35 (expression -> STRING .)
    OR              reduce using rule 35 (expression -> STRING .)
    NAND            reduce using rule 35 (expression -> STRING .)
    $end            reduce using rule 35 (expression -> STRING .)
    }               reduce using rule 35 (expression -> STRING .)
    ;               reduce using rule 35 (expression -> STRING .)
    THEN            reduce using rule 35 (expression -> STRING .)
    ,               reduce using rule 35 (expression -> STRING .)
    LAMBDA          reduce using rule 35 (expression -> STRING .)
    DO              reduce using rule 35 (expression -> STRING .)
    )               reduce using rule 35 (expression -> STRING .)
    ]               reduce using rule 35 (expression -> STRING .)
    IN              reduce using rule 35 (expression -> STRING .)
    ELSE            reduce using rule 35 (expression -> STRING .)


state 15

    (54) expression -> dots . ID ASSIGN expression
    (46) dots_in_struct_expression -> dots . ID

    ID              shift and go to state 54


state 16

    (37) expression -> LOOP . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 55
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 17

    (38) expression -> CHAR .

    +               reduce using rule 38 (expression -> CHAR .)
    -               reduce using rule 38 (expression -> CHAR .)
    *               reduce using rule 38 (expression -> CHAR .)
    /               reduce using rule 38 (expression -> CHAR .)
    AND             reduce using rule 38 (expression -> CHAR .)
    EQ              reduce using rule 38 (expression -> CHAR .)
    =               reduce using rule 38 (expression -> CHAR .)
    >               reduce using rule 38 (expression -> CHAR .)
    <               reduce using rule 38 (expression -> CHAR .)
    GE              reduce using rule 38 (expression -> CHAR .)
    LE              reduce using rule 38 (expression -> CHAR .)
    NEQS            reduce using rule 38 (expression -> CHAR .)
    OR              reduce using rule 38 (expression -> CHAR .)
    NAND            reduce using rule 38 (expression -> CHAR .)
    $end            reduce using rule 38 (expression -> CHAR .)
    }               reduce using rule 38 (expression -> CHAR .)
    ;               reduce using rule 38 (expression -> CHAR .)
    THEN            reduce using rule 38 (expression -> CHAR .)
    ,               reduce using rule 38 (expression -> CHAR .)
    LAMBDA          reduce using rule 38 (expression -> CHAR .)
    DO              reduce using rule 38 (expression -> CHAR .)
    )               reduce using rule 38 (expression -> CHAR .)
    ]               reduce using rule 38 (expression -> CHAR .)
    IN              reduce using rule 38 (expression -> CHAR .)
    ELSE            reduce using rule 38 (expression -> CHAR .)


state 18

    (39) expression -> FOR . expression ; expression ; expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 56
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 19

    (51) expression -> ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression_list                shift and go to state 57
    expression                     shift and go to state 52
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 20

    (45) expression -> WHILE . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 58
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 21

    (47) expression -> [ . expression_list ]
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression_list                shift and go to state 59
    expression                     shift and go to state 52
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 22

    (48) expression -> dots_in_struct_expression . ( )
    (49) expression -> dots_in_struct_expression . ( expression_list )

    (               shift and go to state 60


state 23

    (52) expression -> NOT . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 61
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 24

    (16) dots -> . .
    (17) dots -> . . dots
    (16) dots -> . .
    (17) dots -> . . dots

    ID              reduce using rule 16 (dots -> . .)
    .               shift and go to state 24

    dots                           shift and go to state 62

state 25

    (2) expression -> expression + . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 63
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 26

    (3) expression -> expression - . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 64
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 27

    (4) expression -> expression * . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 65
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 28

    (5) expression -> expression / . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 66
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 29

    (23) expression -> expression AND . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 67
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 30

    (24) expression -> expression EQ . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 68
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 31

    (25) expression -> expression = . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 69
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 32

    (26) expression -> expression > . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 70
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 33

    (27) expression -> expression < . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 71
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 34

    (28) expression -> expression GE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 72
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 35

    (29) expression -> expression LE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 73
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 36

    (30) expression -> expression NEQS . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 74
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 37

    (31) expression -> expression OR . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 75
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 38

    (32) expression -> expression NAND . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 76
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 39

    (1) expression -> - expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 1 (expression -> - expression .)
    -               reduce using rule 1 (expression -> - expression .)
    *               reduce using rule 1 (expression -> - expression .)
    /               reduce using rule 1 (expression -> - expression .)
    AND             reduce using rule 1 (expression -> - expression .)
    EQ              reduce using rule 1 (expression -> - expression .)
    =               reduce using rule 1 (expression -> - expression .)
    >               reduce using rule 1 (expression -> - expression .)
    <               reduce using rule 1 (expression -> - expression .)
    GE              reduce using rule 1 (expression -> - expression .)
    LE              reduce using rule 1 (expression -> - expression .)
    NEQS            reduce using rule 1 (expression -> - expression .)
    OR              reduce using rule 1 (expression -> - expression .)
    NAND            reduce using rule 1 (expression -> - expression .)
    $end            reduce using rule 1 (expression -> - expression .)
    }               reduce using rule 1 (expression -> - expression .)
    ;               reduce using rule 1 (expression -> - expression .)
    THEN            reduce using rule 1 (expression -> - expression .)
    ,               reduce using rule 1 (expression -> - expression .)
    LAMBDA          reduce using rule 1 (expression -> - expression .)
    DO              reduce using rule 1 (expression -> - expression .)
    )               reduce using rule 1 (expression -> - expression .)
    ]               reduce using rule 1 (expression -> - expression .)
    IN              reduce using rule 1 (expression -> - expression .)
    ELSE            reduce using rule 1 (expression -> - expression .)

  ! +               [ shift and go to state 25 ]
  ! -               [ shift and go to state 26 ]
  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 40

    (6) expression -> STRUCT { . sequence_struct }
    (56) sequence_struct -> . seq_assign_expression
    (57) sequence_struct -> . sequence_struct ; seq_assign_expression
    (55) seq_assign_expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    .               shift and go to state 24

    sequence_struct                shift and go to state 77
    seq_assign_expression          shift and go to state 78
    dots                           shift and go to state 79

state 41

    (10) expression -> { sequence . }
    (19) sequence -> sequence . ; expression

    }               shift and go to state 80
    ;               shift and go to state 81


state 42

    (18) sequence -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 18 (sequence -> expression .)
    ;               reduce using rule 18 (sequence -> expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 43

    (11) expression -> EXTEND ID . { sequence_struct }

    {               shift and go to state 82


state 44

    (36) expression -> ID dots . ID
    (43) expression -> ID dots . ID ( )
    (44) expression -> ID dots . ID ( expression_list )

    ID              shift and go to state 83


state 45

    (40) expression -> ID ( . )
    (41) expression -> ID ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    )               shift and go to state 84
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression_list                shift and go to state 85
    expression                     shift and go to state 52
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 46

    (50) expression -> ID [ . NUMBER ]

    NUMBER          shift and go to state 86


state 47

    (53) expression -> ID ASSIGN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 87
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 48

    (12) expression -> LOCAL ID . ASSIGN expression IN expression

    ASSIGN          shift and go to state 88


state 49

    (14) expression -> IF expression . THEN expression
    (21) expression -> IF expression . THEN expression ELSE expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    THEN            shift and go to state 89
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 50

    (15) expression -> IMPORT ID . AS ID
    (22) expression -> IMPORT ID .

    AS              shift and go to state 90
    +               reduce using rule 22 (expression -> IMPORT ID .)
    -               reduce using rule 22 (expression -> IMPORT ID .)
    *               reduce using rule 22 (expression -> IMPORT ID .)
    /               reduce using rule 22 (expression -> IMPORT ID .)
    AND             reduce using rule 22 (expression -> IMPORT ID .)
    EQ              reduce using rule 22 (expression -> IMPORT ID .)
    =               reduce using rule 22 (expression -> IMPORT ID .)
    >               reduce using rule 22 (expression -> IMPORT ID .)
    <               reduce using rule 22 (expression -> IMPORT ID .)
    GE              reduce using rule 22 (expression -> IMPORT ID .)
    LE              reduce using rule 22 (expression -> IMPORT ID .)
    NEQS            reduce using rule 22 (expression -> IMPORT ID .)
    OR              reduce using rule 22 (expression -> IMPORT ID .)
    NAND            reduce using rule 22 (expression -> IMPORT ID .)
    $end            reduce using rule 22 (expression -> IMPORT ID .)
    }               reduce using rule 22 (expression -> IMPORT ID .)
    ;               reduce using rule 22 (expression -> IMPORT ID .)
    THEN            reduce using rule 22 (expression -> IMPORT ID .)
    ,               reduce using rule 22 (expression -> IMPORT ID .)
    LAMBDA          reduce using rule 22 (expression -> IMPORT ID .)
    DO              reduce using rule 22 (expression -> IMPORT ID .)
    )               reduce using rule 22 (expression -> IMPORT ID .)
    ]               reduce using rule 22 (expression -> IMPORT ID .)
    IN              reduce using rule 22 (expression -> IMPORT ID .)
    ELSE            reduce using rule 22 (expression -> IMPORT ID .)


state 51

    (33) expression -> LAMBDA_START LAMBDA . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 91
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 52

    (7) expression_list -> expression . , expression_list
    (8) expression_list -> expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ,               shift and go to state 92
    LAMBDA          reduce using rule 8 (expression_list -> expression .)
    )               reduce using rule 8 (expression_list -> expression .)
    ]               reduce using rule 8 (expression_list -> expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 53

    (34) expression -> LAMBDA_START expression_list . LAMBDA expression

    LAMBDA          shift and go to state 93


state 54

    (54) expression -> dots ID . ASSIGN expression
    (46) dots_in_struct_expression -> dots ID .

    ASSIGN          shift and go to state 94
    (               reduce using rule 46 (dots_in_struct_expression -> dots ID .)


state 55

    (37) expression -> LOOP expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 95
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 56

    (39) expression -> FOR expression . ; expression ; expression DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ;               shift and go to state 96
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 57

    (51) expression -> ( expression_list . )

    )               shift and go to state 97


state 58

    (45) expression -> WHILE expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 98
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 59

    (47) expression -> [ expression_list . ]

    ]               shift and go to state 99


state 60

    (48) expression -> dots_in_struct_expression ( . )
    (49) expression -> dots_in_struct_expression ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    )               shift and go to state 100
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    dots_in_struct_expression      shift and go to state 22
    expression_list                shift and go to state 101
    expression                     shift and go to state 52
    dots                           shift and go to state 15

state 61

    (52) expression -> NOT expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 52 (expression -> NOT expression .)
    -               reduce using rule 52 (expression -> NOT expression .)
    *               reduce using rule 52 (expression -> NOT expression .)
    /               reduce using rule 52 (expression -> NOT expression .)
    AND             reduce using rule 52 (expression -> NOT expression .)
    EQ              reduce using rule 52 (expression -> NOT expression .)
    =               reduce using rule 52 (expression -> NOT expression .)
    >               reduce using rule 52 (expression -> NOT expression .)
    <               reduce using rule 52 (expression -> NOT expression .)
    GE              reduce using rule 52 (expression -> NOT expression .)
    LE              reduce using rule 52 (expression -> NOT expression .)
    NEQS            reduce using rule 52 (expression -> NOT expression .)
    OR              reduce using rule 52 (expression -> NOT expression .)
    NAND            reduce using rule 52 (expression -> NOT expression .)
    $end            reduce using rule 52 (expression -> NOT expression .)
    }               reduce using rule 52 (expression -> NOT expression .)
    ;               reduce using rule 52 (expression -> NOT expression .)
    THEN            reduce using rule 52 (expression -> NOT expression .)
    ,               reduce using rule 52 (expression -> NOT expression .)
    LAMBDA          reduce using rule 52 (expression -> NOT expression .)
    DO              reduce using rule 52 (expression -> NOT expression .)
    )               reduce using rule 52 (expression -> NOT expression .)
    ]               reduce using rule 52 (expression -> NOT expression .)
    IN              reduce using rule 52 (expression -> NOT expression .)
    ELSE            reduce using rule 52 (expression -> NOT expression .)

  ! +               [ shift and go to state 25 ]
  ! -               [ shift and go to state 26 ]
  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 62

    (17) dots -> . dots .

    ID              reduce using rule 17 (dots -> . dots .)


state 63

    (2) expression -> expression + expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 2 (expression -> expression + expression .)
    -               reduce using rule 2 (expression -> expression + expression .)
    AND             reduce using rule 2 (expression -> expression + expression .)
    EQ              reduce using rule 2 (expression -> expression + expression .)
    =               reduce using rule 2 (expression -> expression + expression .)
    >               reduce using rule 2 (expression -> expression + expression .)
    <               reduce using rule 2 (expression -> expression + expression .)
    GE              reduce using rule 2 (expression -> expression + expression .)
    LE              reduce using rule 2 (expression -> expression + expression .)
    NEQS            reduce using rule 2 (expression -> expression + expression .)
    OR              reduce using rule 2 (expression -> expression + expression .)
    NAND            reduce using rule 2 (expression -> expression + expression .)
    $end            reduce using rule 2 (expression -> expression + expression .)
    }               reduce using rule 2 (expression -> expression + expression .)
    ;               reduce using rule 2 (expression -> expression + expression .)
    THEN            reduce using rule 2 (expression -> expression + expression .)
    ,               reduce using rule 2 (expression -> expression + expression .)
    LAMBDA          reduce using rule 2 (expression -> expression + expression .)
    DO              reduce using rule 2 (expression -> expression + expression .)
    )               reduce using rule 2 (expression -> expression + expression .)
    ]               reduce using rule 2 (expression -> expression + expression .)
    IN              reduce using rule 2 (expression -> expression + expression .)
    ELSE            reduce using rule 2 (expression -> expression + expression .)
    *               shift and go to state 27
    /               shift and go to state 28

  ! *               [ reduce using rule 2 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 2 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 25 ]
  ! -               [ shift and go to state 26 ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 64

    (3) expression -> expression - expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 3 (expression -> expression - expression .)
    -               reduce using rule 3 (expression -> expression - expression .)
    AND             reduce using rule 3 (expression -> expression - expression .)
    EQ              reduce using rule 3 (expression -> expression - expression .)
    =               reduce using rule 3 (expression -> expression - expression .)
    >               reduce using rule 3 (expression -> expression - expression .)
    <               reduce using rule 3 (expression -> expression - expression .)
    GE              reduce using rule 3 (expression -> expression - expression .)
    LE              reduce using rule 3 (expression -> expression - expression .)
    NEQS            reduce using rule 3 (expression -> expression - expression .)
    OR              reduce using rule 3 (expression -> expression - expression .)
    NAND            reduce using rule 3 (expression -> expression - expression .)
    $end            reduce using rule 3 (expression -> expression - expression .)
    }               reduce using rule 3 (expression -> expression - expression .)
    ;               reduce using rule 3 (expression -> expression - expression .)
    THEN            reduce using rule 3 (expression -> expression - expression .)
    ,               reduce using rule 3 (expression -> expression - expression .)
    LAMBDA          reduce using rule 3 (expression -> expression - expression .)
    DO              reduce using rule 3 (expression -> expression - expression .)
    )               reduce using rule 3 (expression -> expression - expression .)
    ]               reduce using rule 3 (expression -> expression - expression .)
    IN              reduce using rule 3 (expression -> expression - expression .)
    ELSE            reduce using rule 3 (expression -> expression - expression .)
    *               shift and go to state 27
    /               shift and go to state 28

  ! *               [ reduce using rule 3 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 3 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 25 ]
  ! -               [ shift and go to state 26 ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 65

    (4) expression -> expression * expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 4 (expression -> expression * expression .)
    -               reduce using rule 4 (expression -> expression * expression .)
    *               reduce using rule 4 (expression -> expression * expression .)
    /               reduce using rule 4 (expression -> expression * expression .)
    AND             reduce using rule 4 (expression -> expression * expression .)
    EQ              reduce using rule 4 (expression -> expression * expression .)
    =               reduce using rule 4 (expression -> expression * expression .)
    >               reduce using rule 4 (expression -> expression * expression .)
    <               reduce using rule 4 (expression -> expression * expression .)
    GE              reduce using rule 4 (expression -> expression * expression .)
    LE              reduce using rule 4 (expression -> expression * expression .)
    NEQS            reduce using rule 4 (expression -> expression * expression .)
    OR              reduce using rule 4 (expression -> expression * expression .)
    NAND            reduce using rule 4 (expression -> expression * expression .)
    $end            reduce using rule 4 (expression -> expression * expression .)
    }               reduce using rule 4 (expression -> expression * expression .)
    ;               reduce using rule 4 (expression -> expression * expression .)
    THEN            reduce using rule 4 (expression -> expression * expression .)
    ,               reduce using rule 4 (expression -> expression * expression .)
    LAMBDA          reduce using rule 4 (expression -> expression * expression .)
    DO              reduce using rule 4 (expression -> expression * expression .)
    )               reduce using rule 4 (expression -> expression * expression .)
    ]               reduce using rule 4 (expression -> expression * expression .)
    IN              reduce using rule 4 (expression -> expression * expression .)
    ELSE            reduce using rule 4 (expression -> expression * expression .)

  ! +               [ shift and go to state 25 ]
  ! -               [ shift and go to state 26 ]
  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 66

    (5) expression -> expression / expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    +               reduce using rule 5 (expression -> expression / expression .)
    -               reduce using rule 5 (expression -> expression / expression .)
    *               reduce using rule 5 (expression -> expression / expression .)
    /               reduce using rule 5 (expression -> expression / expression .)
    AND             reduce using rule 5 (expression -> expression / expression .)
    EQ              reduce using rule 5 (expression -> expression / expression .)
    =               reduce using rule 5 (expression -> expression / expression .)
    >               reduce using rule 5 (expression -> expression / expression .)
    <               reduce using rule 5 (expression -> expression / expression .)
    GE              reduce using rule 5 (expression -> expression / expression .)
    LE              reduce using rule 5 (expression -> expression / expression .)
    NEQS            reduce using rule 5 (expression -> expression / expression .)
    OR              reduce using rule 5 (expression -> expression / expression .)
    NAND            reduce using rule 5 (expression -> expression / expression .)
    $end            reduce using rule 5 (expression -> expression / expression .)
    }               reduce using rule 5 (expression -> expression / expression .)
    ;               reduce using rule 5 (expression -> expression / expression .)
    THEN            reduce using rule 5 (expression -> expression / expression .)
    ,               reduce using rule 5 (expression -> expression / expression .)
    LAMBDA          reduce using rule 5 (expression -> expression / expression .)
    DO              reduce using rule 5 (expression -> expression / expression .)
    )               reduce using rule 5 (expression -> expression / expression .)
    ]               reduce using rule 5 (expression -> expression / expression .)
    IN              reduce using rule 5 (expression -> expression / expression .)
    ELSE            reduce using rule 5 (expression -> expression / expression .)

  ! +               [ shift and go to state 25 ]
  ! -               [ shift and go to state 26 ]
  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 67

    (23) expression -> expression AND expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 23 (expression -> expression AND expression .)
    OR              reduce using rule 23 (expression -> expression AND expression .)
    NAND            reduce using rule 23 (expression -> expression AND expression .)
    $end            reduce using rule 23 (expression -> expression AND expression .)
    }               reduce using rule 23 (expression -> expression AND expression .)
    ;               reduce using rule 23 (expression -> expression AND expression .)
    THEN            reduce using rule 23 (expression -> expression AND expression .)
    ,               reduce using rule 23 (expression -> expression AND expression .)
    LAMBDA          reduce using rule 23 (expression -> expression AND expression .)
    DO              reduce using rule 23 (expression -> expression AND expression .)
    )               reduce using rule 23 (expression -> expression AND expression .)
    ]               reduce using rule 23 (expression -> expression AND expression .)
    IN              reduce using rule 23 (expression -> expression AND expression .)
    ELSE            reduce using rule 23 (expression -> expression AND expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36

  ! +               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! =               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! NEQS            [ reduce using rule 23 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 68

    (24) expression -> expression EQ expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 24 (expression -> expression EQ expression .)
    EQ              reduce using rule 24 (expression -> expression EQ expression .)
    =               reduce using rule 24 (expression -> expression EQ expression .)
    NEQS            reduce using rule 24 (expression -> expression EQ expression .)
    OR              reduce using rule 24 (expression -> expression EQ expression .)
    NAND            reduce using rule 24 (expression -> expression EQ expression .)
    $end            reduce using rule 24 (expression -> expression EQ expression .)
    }               reduce using rule 24 (expression -> expression EQ expression .)
    ;               reduce using rule 24 (expression -> expression EQ expression .)
    THEN            reduce using rule 24 (expression -> expression EQ expression .)
    ,               reduce using rule 24 (expression -> expression EQ expression .)
    LAMBDA          reduce using rule 24 (expression -> expression EQ expression .)
    DO              reduce using rule 24 (expression -> expression EQ expression .)
    )               reduce using rule 24 (expression -> expression EQ expression .)
    ]               reduce using rule 24 (expression -> expression EQ expression .)
    IN              reduce using rule 24 (expression -> expression EQ expression .)
    ELSE            reduce using rule 24 (expression -> expression EQ expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35

  ! +               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! >               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! <               [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 24 (expression -> expression EQ expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 69

    (25) expression -> expression = expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 25 (expression -> expression = expression .)
    EQ              reduce using rule 25 (expression -> expression = expression .)
    =               reduce using rule 25 (expression -> expression = expression .)
    NEQS            reduce using rule 25 (expression -> expression = expression .)
    OR              reduce using rule 25 (expression -> expression = expression .)
    NAND            reduce using rule 25 (expression -> expression = expression .)
    $end            reduce using rule 25 (expression -> expression = expression .)
    }               reduce using rule 25 (expression -> expression = expression .)
    ;               reduce using rule 25 (expression -> expression = expression .)
    THEN            reduce using rule 25 (expression -> expression = expression .)
    ,               reduce using rule 25 (expression -> expression = expression .)
    LAMBDA          reduce using rule 25 (expression -> expression = expression .)
    DO              reduce using rule 25 (expression -> expression = expression .)
    )               reduce using rule 25 (expression -> expression = expression .)
    ]               reduce using rule 25 (expression -> expression = expression .)
    IN              reduce using rule 25 (expression -> expression = expression .)
    ELSE            reduce using rule 25 (expression -> expression = expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35

  ! +               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! -               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! *               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! /               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! >               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! <               [ reduce using rule 25 (expression -> expression = expression .) ]
  ! GE              [ reduce using rule 25 (expression -> expression = expression .) ]
  ! LE              [ reduce using rule 25 (expression -> expression = expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 70

    (26) expression -> expression > expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 26 (expression -> expression > expression .)
    EQ              reduce using rule 26 (expression -> expression > expression .)
    =               reduce using rule 26 (expression -> expression > expression .)
    >               reduce using rule 26 (expression -> expression > expression .)
    <               reduce using rule 26 (expression -> expression > expression .)
    GE              reduce using rule 26 (expression -> expression > expression .)
    LE              reduce using rule 26 (expression -> expression > expression .)
    NEQS            reduce using rule 26 (expression -> expression > expression .)
    OR              reduce using rule 26 (expression -> expression > expression .)
    NAND            reduce using rule 26 (expression -> expression > expression .)
    $end            reduce using rule 26 (expression -> expression > expression .)
    }               reduce using rule 26 (expression -> expression > expression .)
    ;               reduce using rule 26 (expression -> expression > expression .)
    THEN            reduce using rule 26 (expression -> expression > expression .)
    ,               reduce using rule 26 (expression -> expression > expression .)
    LAMBDA          reduce using rule 26 (expression -> expression > expression .)
    DO              reduce using rule 26 (expression -> expression > expression .)
    )               reduce using rule 26 (expression -> expression > expression .)
    ]               reduce using rule 26 (expression -> expression > expression .)
    IN              reduce using rule 26 (expression -> expression > expression .)
    ELSE            reduce using rule 26 (expression -> expression > expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 26 (expression -> expression > expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 71

    (27) expression -> expression < expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 27 (expression -> expression < expression .)
    EQ              reduce using rule 27 (expression -> expression < expression .)
    =               reduce using rule 27 (expression -> expression < expression .)
    >               reduce using rule 27 (expression -> expression < expression .)
    <               reduce using rule 27 (expression -> expression < expression .)
    GE              reduce using rule 27 (expression -> expression < expression .)
    LE              reduce using rule 27 (expression -> expression < expression .)
    NEQS            reduce using rule 27 (expression -> expression < expression .)
    OR              reduce using rule 27 (expression -> expression < expression .)
    NAND            reduce using rule 27 (expression -> expression < expression .)
    $end            reduce using rule 27 (expression -> expression < expression .)
    }               reduce using rule 27 (expression -> expression < expression .)
    ;               reduce using rule 27 (expression -> expression < expression .)
    THEN            reduce using rule 27 (expression -> expression < expression .)
    ,               reduce using rule 27 (expression -> expression < expression .)
    LAMBDA          reduce using rule 27 (expression -> expression < expression .)
    DO              reduce using rule 27 (expression -> expression < expression .)
    )               reduce using rule 27 (expression -> expression < expression .)
    ]               reduce using rule 27 (expression -> expression < expression .)
    IN              reduce using rule 27 (expression -> expression < expression .)
    ELSE            reduce using rule 27 (expression -> expression < expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 27 (expression -> expression < expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 72

    (28) expression -> expression GE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 28 (expression -> expression GE expression .)
    EQ              reduce using rule 28 (expression -> expression GE expression .)
    =               reduce using rule 28 (expression -> expression GE expression .)
    >               reduce using rule 28 (expression -> expression GE expression .)
    <               reduce using rule 28 (expression -> expression GE expression .)
    GE              reduce using rule 28 (expression -> expression GE expression .)
    LE              reduce using rule 28 (expression -> expression GE expression .)
    NEQS            reduce using rule 28 (expression -> expression GE expression .)
    OR              reduce using rule 28 (expression -> expression GE expression .)
    NAND            reduce using rule 28 (expression -> expression GE expression .)
    $end            reduce using rule 28 (expression -> expression GE expression .)
    }               reduce using rule 28 (expression -> expression GE expression .)
    ;               reduce using rule 28 (expression -> expression GE expression .)
    THEN            reduce using rule 28 (expression -> expression GE expression .)
    ,               reduce using rule 28 (expression -> expression GE expression .)
    LAMBDA          reduce using rule 28 (expression -> expression GE expression .)
    DO              reduce using rule 28 (expression -> expression GE expression .)
    )               reduce using rule 28 (expression -> expression GE expression .)
    ]               reduce using rule 28 (expression -> expression GE expression .)
    IN              reduce using rule 28 (expression -> expression GE expression .)
    ELSE            reduce using rule 28 (expression -> expression GE expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 28 (expression -> expression GE expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 73

    (29) expression -> expression LE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 29 (expression -> expression LE expression .)
    EQ              reduce using rule 29 (expression -> expression LE expression .)
    =               reduce using rule 29 (expression -> expression LE expression .)
    >               reduce using rule 29 (expression -> expression LE expression .)
    <               reduce using rule 29 (expression -> expression LE expression .)
    GE              reduce using rule 29 (expression -> expression LE expression .)
    LE              reduce using rule 29 (expression -> expression LE expression .)
    NEQS            reduce using rule 29 (expression -> expression LE expression .)
    OR              reduce using rule 29 (expression -> expression LE expression .)
    NAND            reduce using rule 29 (expression -> expression LE expression .)
    $end            reduce using rule 29 (expression -> expression LE expression .)
    }               reduce using rule 29 (expression -> expression LE expression .)
    ;               reduce using rule 29 (expression -> expression LE expression .)
    THEN            reduce using rule 29 (expression -> expression LE expression .)
    ,               reduce using rule 29 (expression -> expression LE expression .)
    LAMBDA          reduce using rule 29 (expression -> expression LE expression .)
    DO              reduce using rule 29 (expression -> expression LE expression .)
    )               reduce using rule 29 (expression -> expression LE expression .)
    ]               reduce using rule 29 (expression -> expression LE expression .)
    IN              reduce using rule 29 (expression -> expression LE expression .)
    ELSE            reduce using rule 29 (expression -> expression LE expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28

  ! +               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 29 (expression -> expression LE expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! >               [ shift and go to state 32 ]
  ! <               [ shift and go to state 33 ]
  ! GE              [ shift and go to state 34 ]
  ! LE              [ shift and go to state 35 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 74

    (30) expression -> expression NEQS expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 30 (expression -> expression NEQS expression .)
    EQ              reduce using rule 30 (expression -> expression NEQS expression .)
    =               reduce using rule 30 (expression -> expression NEQS expression .)
    NEQS            reduce using rule 30 (expression -> expression NEQS expression .)
    OR              reduce using rule 30 (expression -> expression NEQS expression .)
    NAND            reduce using rule 30 (expression -> expression NEQS expression .)
    $end            reduce using rule 30 (expression -> expression NEQS expression .)
    }               reduce using rule 30 (expression -> expression NEQS expression .)
    ;               reduce using rule 30 (expression -> expression NEQS expression .)
    THEN            reduce using rule 30 (expression -> expression NEQS expression .)
    ,               reduce using rule 30 (expression -> expression NEQS expression .)
    LAMBDA          reduce using rule 30 (expression -> expression NEQS expression .)
    DO              reduce using rule 30 (expression -> expression NEQS expression .)
    )               reduce using rule 30 (expression -> expression NEQS expression .)
    ]               reduce using rule 30 (expression -> expression NEQS expression .)
    IN              reduce using rule 30 (expression -> expression NEQS expression .)
    ELSE            reduce using rule 30 (expression -> expression NEQS expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35

  ! +               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! -               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! *               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! /               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! >               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! <               [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! GE              [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! LE              [ reduce using rule 30 (expression -> expression NEQS expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 30 ]
  ! =               [ shift and go to state 31 ]
  ! NEQS            [ shift and go to state 36 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 75

    (31) expression -> expression OR expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    OR              reduce using rule 31 (expression -> expression OR expression .)
    $end            reduce using rule 31 (expression -> expression OR expression .)
    }               reduce using rule 31 (expression -> expression OR expression .)
    ;               reduce using rule 31 (expression -> expression OR expression .)
    THEN            reduce using rule 31 (expression -> expression OR expression .)
    ,               reduce using rule 31 (expression -> expression OR expression .)
    LAMBDA          reduce using rule 31 (expression -> expression OR expression .)
    DO              reduce using rule 31 (expression -> expression OR expression .)
    )               reduce using rule 31 (expression -> expression OR expression .)
    ]               reduce using rule 31 (expression -> expression OR expression .)
    IN              reduce using rule 31 (expression -> expression OR expression .)
    ELSE            reduce using rule 31 (expression -> expression OR expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    NAND            shift and go to state 38

  ! +               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! =               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! NEQS            [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! NAND            [ reduce using rule 31 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 37 ]


state 76

    (32) expression -> expression NAND expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    AND             reduce using rule 32 (expression -> expression NAND expression .)
    OR              reduce using rule 32 (expression -> expression NAND expression .)
    NAND            reduce using rule 32 (expression -> expression NAND expression .)
    $end            reduce using rule 32 (expression -> expression NAND expression .)
    }               reduce using rule 32 (expression -> expression NAND expression .)
    ;               reduce using rule 32 (expression -> expression NAND expression .)
    THEN            reduce using rule 32 (expression -> expression NAND expression .)
    ,               reduce using rule 32 (expression -> expression NAND expression .)
    LAMBDA          reduce using rule 32 (expression -> expression NAND expression .)
    DO              reduce using rule 32 (expression -> expression NAND expression .)
    )               reduce using rule 32 (expression -> expression NAND expression .)
    ]               reduce using rule 32 (expression -> expression NAND expression .)
    IN              reduce using rule 32 (expression -> expression NAND expression .)
    ELSE            reduce using rule 32 (expression -> expression NAND expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36

  ! +               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! -               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! *               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! /               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! EQ              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! =               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! >               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! <               [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! GE              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! LE              [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! NEQS            [ reduce using rule 32 (expression -> expression NAND expression .) ]
  ! AND             [ shift and go to state 29 ]
  ! OR              [ shift and go to state 37 ]
  ! NAND            [ shift and go to state 38 ]


state 77

    (6) expression -> STRUCT { sequence_struct . }
    (57) sequence_struct -> sequence_struct . ; seq_assign_expression

    }               shift and go to state 102
    ;               shift and go to state 103


state 78

    (56) sequence_struct -> seq_assign_expression .

    }               reduce using rule 56 (sequence_struct -> seq_assign_expression .)
    ;               reduce using rule 56 (sequence_struct -> seq_assign_expression .)


state 79

    (55) seq_assign_expression -> dots . ID ASSIGN expression

    ID              shift and go to state 104


state 80

    (10) expression -> { sequence } .

    +               reduce using rule 10 (expression -> { sequence } .)
    -               reduce using rule 10 (expression -> { sequence } .)
    *               reduce using rule 10 (expression -> { sequence } .)
    /               reduce using rule 10 (expression -> { sequence } .)
    AND             reduce using rule 10 (expression -> { sequence } .)
    EQ              reduce using rule 10 (expression -> { sequence } .)
    =               reduce using rule 10 (expression -> { sequence } .)
    >               reduce using rule 10 (expression -> { sequence } .)
    <               reduce using rule 10 (expression -> { sequence } .)
    GE              reduce using rule 10 (expression -> { sequence } .)
    LE              reduce using rule 10 (expression -> { sequence } .)
    NEQS            reduce using rule 10 (expression -> { sequence } .)
    OR              reduce using rule 10 (expression -> { sequence } .)
    NAND            reduce using rule 10 (expression -> { sequence } .)
    $end            reduce using rule 10 (expression -> { sequence } .)
    }               reduce using rule 10 (expression -> { sequence } .)
    ;               reduce using rule 10 (expression -> { sequence } .)
    THEN            reduce using rule 10 (expression -> { sequence } .)
    ,               reduce using rule 10 (expression -> { sequence } .)
    LAMBDA          reduce using rule 10 (expression -> { sequence } .)
    DO              reduce using rule 10 (expression -> { sequence } .)
    )               reduce using rule 10 (expression -> { sequence } .)
    ]               reduce using rule 10 (expression -> { sequence } .)
    IN              reduce using rule 10 (expression -> { sequence } .)
    ELSE            reduce using rule 10 (expression -> { sequence } .)


state 81

    (19) sequence -> sequence ; . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 105
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 82

    (11) expression -> EXTEND ID { . sequence_struct }
    (56) sequence_struct -> . seq_assign_expression
    (57) sequence_struct -> . sequence_struct ; seq_assign_expression
    (55) seq_assign_expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    .               shift and go to state 24

    sequence_struct                shift and go to state 106
    seq_assign_expression          shift and go to state 78
    dots                           shift and go to state 79

state 83

    (36) expression -> ID dots ID .
    (43) expression -> ID dots ID . ( )
    (44) expression -> ID dots ID . ( expression_list )

    +               reduce using rule 36 (expression -> ID dots ID .)
    -               reduce using rule 36 (expression -> ID dots ID .)
    *               reduce using rule 36 (expression -> ID dots ID .)
    /               reduce using rule 36 (expression -> ID dots ID .)
    AND             reduce using rule 36 (expression -> ID dots ID .)
    EQ              reduce using rule 36 (expression -> ID dots ID .)
    =               reduce using rule 36 (expression -> ID dots ID .)
    >               reduce using rule 36 (expression -> ID dots ID .)
    <               reduce using rule 36 (expression -> ID dots ID .)
    GE              reduce using rule 36 (expression -> ID dots ID .)
    LE              reduce using rule 36 (expression -> ID dots ID .)
    NEQS            reduce using rule 36 (expression -> ID dots ID .)
    OR              reduce using rule 36 (expression -> ID dots ID .)
    NAND            reduce using rule 36 (expression -> ID dots ID .)
    $end            reduce using rule 36 (expression -> ID dots ID .)
    }               reduce using rule 36 (expression -> ID dots ID .)
    ;               reduce using rule 36 (expression -> ID dots ID .)
    THEN            reduce using rule 36 (expression -> ID dots ID .)
    ,               reduce using rule 36 (expression -> ID dots ID .)
    LAMBDA          reduce using rule 36 (expression -> ID dots ID .)
    DO              reduce using rule 36 (expression -> ID dots ID .)
    )               reduce using rule 36 (expression -> ID dots ID .)
    ]               reduce using rule 36 (expression -> ID dots ID .)
    IN              reduce using rule 36 (expression -> ID dots ID .)
    ELSE            reduce using rule 36 (expression -> ID dots ID .)
    (               shift and go to state 107


state 84

    (40) expression -> ID ( ) .

    +               reduce using rule 40 (expression -> ID ( ) .)
    -               reduce using rule 40 (expression -> ID ( ) .)
    *               reduce using rule 40 (expression -> ID ( ) .)
    /               reduce using rule 40 (expression -> ID ( ) .)
    AND             reduce using rule 40 (expression -> ID ( ) .)
    EQ              reduce using rule 40 (expression -> ID ( ) .)
    =               reduce using rule 40 (expression -> ID ( ) .)
    >               reduce using rule 40 (expression -> ID ( ) .)
    <               reduce using rule 40 (expression -> ID ( ) .)
    GE              reduce using rule 40 (expression -> ID ( ) .)
    LE              reduce using rule 40 (expression -> ID ( ) .)
    NEQS            reduce using rule 40 (expression -> ID ( ) .)
    OR              reduce using rule 40 (expression -> ID ( ) .)
    NAND            reduce using rule 40 (expression -> ID ( ) .)
    $end            reduce using rule 40 (expression -> ID ( ) .)
    }               reduce using rule 40 (expression -> ID ( ) .)
    ;               reduce using rule 40 (expression -> ID ( ) .)
    THEN            reduce using rule 40 (expression -> ID ( ) .)
    ,               reduce using rule 40 (expression -> ID ( ) .)
    LAMBDA          reduce using rule 40 (expression -> ID ( ) .)
    DO              reduce using rule 40 (expression -> ID ( ) .)
    )               reduce using rule 40 (expression -> ID ( ) .)
    ]               reduce using rule 40 (expression -> ID ( ) .)
    IN              reduce using rule 40 (expression -> ID ( ) .)
    ELSE            reduce using rule 40 (expression -> ID ( ) .)


state 85

    (41) expression -> ID ( expression_list . )

    )               shift and go to state 108


state 86

    (50) expression -> ID [ NUMBER . ]

    ]               shift and go to state 109


state 87

    (53) expression -> ID ASSIGN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 53 (expression -> ID ASSIGN expression .)
    }               reduce using rule 53 (expression -> ID ASSIGN expression .)
    ;               reduce using rule 53 (expression -> ID ASSIGN expression .)
    THEN            reduce using rule 53 (expression -> ID ASSIGN expression .)
    ,               reduce using rule 53 (expression -> ID ASSIGN expression .)
    LAMBDA          reduce using rule 53 (expression -> ID ASSIGN expression .)
    DO              reduce using rule 53 (expression -> ID ASSIGN expression .)
    )               reduce using rule 53 (expression -> ID ASSIGN expression .)
    ]               reduce using rule 53 (expression -> ID ASSIGN expression .)
    IN              reduce using rule 53 (expression -> ID ASSIGN expression .)
    ELSE            reduce using rule 53 (expression -> ID ASSIGN expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! -               [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! *               [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! /               [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! AND             [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! EQ              [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! =               [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! >               [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! <               [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! GE              [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! LE              [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! NEQS            [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! OR              [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]
  ! NAND            [ reduce using rule 53 (expression -> ID ASSIGN expression .) ]


state 88

    (12) expression -> LOCAL ID ASSIGN . expression IN expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 110
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 89

    (14) expression -> IF expression THEN . expression
    (21) expression -> IF expression THEN . expression ELSE expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 111
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 90

    (15) expression -> IMPORT ID AS . ID

    ID              shift and go to state 112


state 91

    (33) expression -> LAMBDA_START LAMBDA expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    }               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ;               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    THEN            reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ,               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    LAMBDA          reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    DO              reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    )               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ]               reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    IN              reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    ELSE            reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! -               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! *               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! /               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! AND             [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! EQ              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! =               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! >               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! <               [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! GE              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! LE              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! NEQS            [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! OR              [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]
  ! NAND            [ reduce using rule 33 (expression -> LAMBDA_START LAMBDA expression .) ]


state 92

    (7) expression_list -> expression , . expression_list
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 52
    expression_list                shift and go to state 113
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 93

    (34) expression -> LAMBDA_START expression_list LAMBDA . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 114
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 94

    (54) expression -> dots ID ASSIGN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    dots                           shift and go to state 15
    expression                     shift and go to state 115
    dots_in_struct_expression      shift and go to state 22

state 95

    (37) expression -> LOOP expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 116
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 96

    (39) expression -> FOR expression ; . expression ; expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 117
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 97

    (51) expression -> ( expression_list ) .

    +               reduce using rule 51 (expression -> ( expression_list ) .)
    -               reduce using rule 51 (expression -> ( expression_list ) .)
    *               reduce using rule 51 (expression -> ( expression_list ) .)
    /               reduce using rule 51 (expression -> ( expression_list ) .)
    AND             reduce using rule 51 (expression -> ( expression_list ) .)
    EQ              reduce using rule 51 (expression -> ( expression_list ) .)
    =               reduce using rule 51 (expression -> ( expression_list ) .)
    >               reduce using rule 51 (expression -> ( expression_list ) .)
    <               reduce using rule 51 (expression -> ( expression_list ) .)
    GE              reduce using rule 51 (expression -> ( expression_list ) .)
    LE              reduce using rule 51 (expression -> ( expression_list ) .)
    NEQS            reduce using rule 51 (expression -> ( expression_list ) .)
    OR              reduce using rule 51 (expression -> ( expression_list ) .)
    NAND            reduce using rule 51 (expression -> ( expression_list ) .)
    $end            reduce using rule 51 (expression -> ( expression_list ) .)
    }               reduce using rule 51 (expression -> ( expression_list ) .)
    ;               reduce using rule 51 (expression -> ( expression_list ) .)
    THEN            reduce using rule 51 (expression -> ( expression_list ) .)
    ,               reduce using rule 51 (expression -> ( expression_list ) .)
    LAMBDA          reduce using rule 51 (expression -> ( expression_list ) .)
    DO              reduce using rule 51 (expression -> ( expression_list ) .)
    )               reduce using rule 51 (expression -> ( expression_list ) .)
    ]               reduce using rule 51 (expression -> ( expression_list ) .)
    IN              reduce using rule 51 (expression -> ( expression_list ) .)
    ELSE            reduce using rule 51 (expression -> ( expression_list ) .)


state 98

    (45) expression -> WHILE expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 118
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 99

    (47) expression -> [ expression_list ] .

    +               reduce using rule 47 (expression -> [ expression_list ] .)
    -               reduce using rule 47 (expression -> [ expression_list ] .)
    *               reduce using rule 47 (expression -> [ expression_list ] .)
    /               reduce using rule 47 (expression -> [ expression_list ] .)
    AND             reduce using rule 47 (expression -> [ expression_list ] .)
    EQ              reduce using rule 47 (expression -> [ expression_list ] .)
    =               reduce using rule 47 (expression -> [ expression_list ] .)
    >               reduce using rule 47 (expression -> [ expression_list ] .)
    <               reduce using rule 47 (expression -> [ expression_list ] .)
    GE              reduce using rule 47 (expression -> [ expression_list ] .)
    LE              reduce using rule 47 (expression -> [ expression_list ] .)
    NEQS            reduce using rule 47 (expression -> [ expression_list ] .)
    OR              reduce using rule 47 (expression -> [ expression_list ] .)
    NAND            reduce using rule 47 (expression -> [ expression_list ] .)
    $end            reduce using rule 47 (expression -> [ expression_list ] .)
    }               reduce using rule 47 (expression -> [ expression_list ] .)
    ;               reduce using rule 47 (expression -> [ expression_list ] .)
    THEN            reduce using rule 47 (expression -> [ expression_list ] .)
    ,               reduce using rule 47 (expression -> [ expression_list ] .)
    LAMBDA          reduce using rule 47 (expression -> [ expression_list ] .)
    DO              reduce using rule 47 (expression -> [ expression_list ] .)
    )               reduce using rule 47 (expression -> [ expression_list ] .)
    ]               reduce using rule 47 (expression -> [ expression_list ] .)
    IN              reduce using rule 47 (expression -> [ expression_list ] .)
    ELSE            reduce using rule 47 (expression -> [ expression_list ] .)


state 100

    (48) expression -> dots_in_struct_expression ( ) .

    +               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    -               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    *               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    /               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    AND             reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    EQ              reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    =               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    >               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    <               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    GE              reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    LE              reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    NEQS            reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    OR              reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    NAND            reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    $end            reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    }               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    ;               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    THEN            reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    ,               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    LAMBDA          reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    DO              reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    )               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    ]               reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    IN              reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)
    ELSE            reduce using rule 48 (expression -> dots_in_struct_expression ( ) .)


state 101

    (49) expression -> dots_in_struct_expression ( expression_list . )

    )               shift and go to state 119


state 102

    (6) expression -> STRUCT { sequence_struct } .

    +               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    -               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    *               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    /               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    AND             reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    EQ              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    =               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    >               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    <               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    GE              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    LE              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    NEQS            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    OR              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    NAND            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    $end            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    }               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ;               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    THEN            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ,               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    LAMBDA          reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    DO              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    )               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ]               reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    IN              reduce using rule 6 (expression -> STRUCT { sequence_struct } .)
    ELSE            reduce using rule 6 (expression -> STRUCT { sequence_struct } .)


state 103

    (57) sequence_struct -> sequence_struct ; . seq_assign_expression
    (55) seq_assign_expression -> . dots ID ASSIGN expression
    (16) dots -> . .
    (17) dots -> . . dots

    .               shift and go to state 24

    seq_assign_expression          shift and go to state 120
    dots                           shift and go to state 79

state 104

    (55) seq_assign_expression -> dots ID . ASSIGN expression

    ASSIGN          shift and go to state 121


state 105

    (19) sequence -> sequence ; expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 19 (sequence -> sequence ; expression .)
    ;               reduce using rule 19 (sequence -> sequence ; expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 106

    (11) expression -> EXTEND ID { sequence_struct . }
    (57) sequence_struct -> sequence_struct . ; seq_assign_expression

    }               shift and go to state 122
    ;               shift and go to state 103


state 107

    (43) expression -> ID dots ID ( . )
    (44) expression -> ID dots ID ( . expression_list )
    (7) expression_list -> . expression , expression_list
    (8) expression_list -> . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    )               shift and go to state 123
    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    dots                           shift and go to state 15
    expression_list                shift and go to state 124
    expression                     shift and go to state 52
    dots_in_struct_expression      shift and go to state 22

state 108

    (41) expression -> ID ( expression_list ) .

    +               reduce using rule 41 (expression -> ID ( expression_list ) .)
    -               reduce using rule 41 (expression -> ID ( expression_list ) .)
    *               reduce using rule 41 (expression -> ID ( expression_list ) .)
    /               reduce using rule 41 (expression -> ID ( expression_list ) .)
    AND             reduce using rule 41 (expression -> ID ( expression_list ) .)
    EQ              reduce using rule 41 (expression -> ID ( expression_list ) .)
    =               reduce using rule 41 (expression -> ID ( expression_list ) .)
    >               reduce using rule 41 (expression -> ID ( expression_list ) .)
    <               reduce using rule 41 (expression -> ID ( expression_list ) .)
    GE              reduce using rule 41 (expression -> ID ( expression_list ) .)
    LE              reduce using rule 41 (expression -> ID ( expression_list ) .)
    NEQS            reduce using rule 41 (expression -> ID ( expression_list ) .)
    OR              reduce using rule 41 (expression -> ID ( expression_list ) .)
    NAND            reduce using rule 41 (expression -> ID ( expression_list ) .)
    $end            reduce using rule 41 (expression -> ID ( expression_list ) .)
    }               reduce using rule 41 (expression -> ID ( expression_list ) .)
    ;               reduce using rule 41 (expression -> ID ( expression_list ) .)
    THEN            reduce using rule 41 (expression -> ID ( expression_list ) .)
    ,               reduce using rule 41 (expression -> ID ( expression_list ) .)
    LAMBDA          reduce using rule 41 (expression -> ID ( expression_list ) .)
    DO              reduce using rule 41 (expression -> ID ( expression_list ) .)
    )               reduce using rule 41 (expression -> ID ( expression_list ) .)
    ]               reduce using rule 41 (expression -> ID ( expression_list ) .)
    IN              reduce using rule 41 (expression -> ID ( expression_list ) .)
    ELSE            reduce using rule 41 (expression -> ID ( expression_list ) .)


state 109

    (50) expression -> ID [ NUMBER ] .

    +               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    -               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    *               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    /               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    AND             reduce using rule 50 (expression -> ID [ NUMBER ] .)
    EQ              reduce using rule 50 (expression -> ID [ NUMBER ] .)
    =               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    >               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    <               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    GE              reduce using rule 50 (expression -> ID [ NUMBER ] .)
    LE              reduce using rule 50 (expression -> ID [ NUMBER ] .)
    NEQS            reduce using rule 50 (expression -> ID [ NUMBER ] .)
    OR              reduce using rule 50 (expression -> ID [ NUMBER ] .)
    NAND            reduce using rule 50 (expression -> ID [ NUMBER ] .)
    $end            reduce using rule 50 (expression -> ID [ NUMBER ] .)
    }               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    ;               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    THEN            reduce using rule 50 (expression -> ID [ NUMBER ] .)
    ,               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    LAMBDA          reduce using rule 50 (expression -> ID [ NUMBER ] .)
    DO              reduce using rule 50 (expression -> ID [ NUMBER ] .)
    )               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    ]               reduce using rule 50 (expression -> ID [ NUMBER ] .)
    IN              reduce using rule 50 (expression -> ID [ NUMBER ] .)
    ELSE            reduce using rule 50 (expression -> ID [ NUMBER ] .)


state 110

    (12) expression -> LOCAL ID ASSIGN expression . IN expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    IN              shift and go to state 125
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 111

    (14) expression -> IF expression THEN expression .
    (21) expression -> IF expression THEN expression . ELSE expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 14 (expression -> IF expression THEN expression .)
    }               reduce using rule 14 (expression -> IF expression THEN expression .)
    ;               reduce using rule 14 (expression -> IF expression THEN expression .)
    THEN            reduce using rule 14 (expression -> IF expression THEN expression .)
    ,               reduce using rule 14 (expression -> IF expression THEN expression .)
    LAMBDA          reduce using rule 14 (expression -> IF expression THEN expression .)
    DO              reduce using rule 14 (expression -> IF expression THEN expression .)
    )               reduce using rule 14 (expression -> IF expression THEN expression .)
    ]               reduce using rule 14 (expression -> IF expression THEN expression .)
    IN              reduce using rule 14 (expression -> IF expression THEN expression .)
    ELSE            shift and go to state 126
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! -               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! *               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! /               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! AND             [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! EQ              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! =               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! >               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! <               [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! GE              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! LE              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! NEQS            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! OR              [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! NAND            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]
  ! ELSE            [ reduce using rule 14 (expression -> IF expression THEN expression .) ]


state 112

    (15) expression -> IMPORT ID AS ID .

    +               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    -               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    *               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    /               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    AND             reduce using rule 15 (expression -> IMPORT ID AS ID .)
    EQ              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    =               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    >               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    <               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    GE              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    LE              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    NEQS            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    OR              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    NAND            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    $end            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    }               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ;               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    THEN            reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ,               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    LAMBDA          reduce using rule 15 (expression -> IMPORT ID AS ID .)
    DO              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    )               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ]               reduce using rule 15 (expression -> IMPORT ID AS ID .)
    IN              reduce using rule 15 (expression -> IMPORT ID AS ID .)
    ELSE            reduce using rule 15 (expression -> IMPORT ID AS ID .)


state 113

    (7) expression_list -> expression , expression_list .

    LAMBDA          reduce using rule 7 (expression_list -> expression , expression_list .)
    )               reduce using rule 7 (expression_list -> expression , expression_list .)
    ]               reduce using rule 7 (expression_list -> expression , expression_list .)


state 114

    (34) expression -> LAMBDA_START expression_list LAMBDA expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    }               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ;               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    THEN            reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ,               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    LAMBDA          reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    DO              reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    )               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ]               reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    IN              reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    ELSE            reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! -               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! *               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! /               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! AND             [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! EQ              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! =               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! >               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! <               [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! GE              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! LE              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! NEQS            [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! OR              [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]
  ! NAND            [ reduce using rule 34 (expression -> LAMBDA_START expression_list LAMBDA expression .) ]


state 115

    (54) expression -> dots ID ASSIGN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    }               reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    ;               reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    THEN            reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    ,               reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    LAMBDA          reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    DO              reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    )               reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    ]               reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    IN              reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    ELSE            reduce using rule 54 (expression -> dots ID ASSIGN expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! -               [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! *               [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! /               [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! AND             [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! EQ              [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! =               [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! >               [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! <               [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! GE              [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! LE              [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! NEQS            [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! OR              [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]
  ! NAND            [ reduce using rule 54 (expression -> dots ID ASSIGN expression .) ]


state 116

    (37) expression -> LOOP expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 37 (expression -> LOOP expression DO expression .)
    }               reduce using rule 37 (expression -> LOOP expression DO expression .)
    ;               reduce using rule 37 (expression -> LOOP expression DO expression .)
    THEN            reduce using rule 37 (expression -> LOOP expression DO expression .)
    ,               reduce using rule 37 (expression -> LOOP expression DO expression .)
    LAMBDA          reduce using rule 37 (expression -> LOOP expression DO expression .)
    DO              reduce using rule 37 (expression -> LOOP expression DO expression .)
    )               reduce using rule 37 (expression -> LOOP expression DO expression .)
    ]               reduce using rule 37 (expression -> LOOP expression DO expression .)
    IN              reduce using rule 37 (expression -> LOOP expression DO expression .)
    ELSE            reduce using rule 37 (expression -> LOOP expression DO expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! -               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! *               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! /               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! AND             [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! EQ              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! =               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! >               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! <               [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! GE              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! LE              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! NEQS            [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! OR              [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]
  ! NAND            [ reduce using rule 37 (expression -> LOOP expression DO expression .) ]


state 117

    (39) expression -> FOR expression ; expression . ; expression DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    ;               shift and go to state 127
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 118

    (45) expression -> WHILE expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 45 (expression -> WHILE expression DO expression .)
    }               reduce using rule 45 (expression -> WHILE expression DO expression .)
    ;               reduce using rule 45 (expression -> WHILE expression DO expression .)
    THEN            reduce using rule 45 (expression -> WHILE expression DO expression .)
    ,               reduce using rule 45 (expression -> WHILE expression DO expression .)
    LAMBDA          reduce using rule 45 (expression -> WHILE expression DO expression .)
    DO              reduce using rule 45 (expression -> WHILE expression DO expression .)
    )               reduce using rule 45 (expression -> WHILE expression DO expression .)
    ]               reduce using rule 45 (expression -> WHILE expression DO expression .)
    IN              reduce using rule 45 (expression -> WHILE expression DO expression .)
    ELSE            reduce using rule 45 (expression -> WHILE expression DO expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! -               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! *               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! /               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! AND             [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! EQ              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! =               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! >               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! <               [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! GE              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! LE              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! NEQS            [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! OR              [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]
  ! NAND            [ reduce using rule 45 (expression -> WHILE expression DO expression .) ]


state 119

    (49) expression -> dots_in_struct_expression ( expression_list ) .

    +               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    -               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    *               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    /               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    AND             reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    EQ              reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    =               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    >               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    <               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    GE              reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    LE              reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    NEQS            reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    OR              reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    NAND            reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    $end            reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    }               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    ;               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    THEN            reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    ,               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    LAMBDA          reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    DO              reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    )               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    ]               reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    IN              reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)
    ELSE            reduce using rule 49 (expression -> dots_in_struct_expression ( expression_list ) .)


state 120

    (57) sequence_struct -> sequence_struct ; seq_assign_expression .

    }               reduce using rule 57 (sequence_struct -> sequence_struct ; seq_assign_expression .)
    ;               reduce using rule 57 (sequence_struct -> sequence_struct ; seq_assign_expression .)


state 121

    (55) seq_assign_expression -> dots ID ASSIGN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    dots                           shift and go to state 15
    expression                     shift and go to state 128
    dots_in_struct_expression      shift and go to state 22

state 122

    (11) expression -> EXTEND ID { sequence_struct } .

    +               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    -               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    *               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    /               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    AND             reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    EQ              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    =               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    >               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    <               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    GE              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    LE              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    NEQS            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    OR              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    NAND            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    $end            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    }               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ;               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    THEN            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ,               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    LAMBDA          reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    DO              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    )               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ]               reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    IN              reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)
    ELSE            reduce using rule 11 (expression -> EXTEND ID { sequence_struct } .)


state 123

    (43) expression -> ID dots ID ( ) .

    +               reduce using rule 43 (expression -> ID dots ID ( ) .)
    -               reduce using rule 43 (expression -> ID dots ID ( ) .)
    *               reduce using rule 43 (expression -> ID dots ID ( ) .)
    /               reduce using rule 43 (expression -> ID dots ID ( ) .)
    AND             reduce using rule 43 (expression -> ID dots ID ( ) .)
    EQ              reduce using rule 43 (expression -> ID dots ID ( ) .)
    =               reduce using rule 43 (expression -> ID dots ID ( ) .)
    >               reduce using rule 43 (expression -> ID dots ID ( ) .)
    <               reduce using rule 43 (expression -> ID dots ID ( ) .)
    GE              reduce using rule 43 (expression -> ID dots ID ( ) .)
    LE              reduce using rule 43 (expression -> ID dots ID ( ) .)
    NEQS            reduce using rule 43 (expression -> ID dots ID ( ) .)
    OR              reduce using rule 43 (expression -> ID dots ID ( ) .)
    NAND            reduce using rule 43 (expression -> ID dots ID ( ) .)
    $end            reduce using rule 43 (expression -> ID dots ID ( ) .)
    }               reduce using rule 43 (expression -> ID dots ID ( ) .)
    ;               reduce using rule 43 (expression -> ID dots ID ( ) .)
    THEN            reduce using rule 43 (expression -> ID dots ID ( ) .)
    ,               reduce using rule 43 (expression -> ID dots ID ( ) .)
    LAMBDA          reduce using rule 43 (expression -> ID dots ID ( ) .)
    DO              reduce using rule 43 (expression -> ID dots ID ( ) .)
    )               reduce using rule 43 (expression -> ID dots ID ( ) .)
    ]               reduce using rule 43 (expression -> ID dots ID ( ) .)
    IN              reduce using rule 43 (expression -> ID dots ID ( ) .)
    ELSE            reduce using rule 43 (expression -> ID dots ID ( ) .)


state 124

    (44) expression -> ID dots ID ( expression_list . )

    )               shift and go to state 129


state 125

    (12) expression -> LOCAL ID ASSIGN expression IN . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 130
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 126

    (21) expression -> IF expression THEN expression ELSE . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 131
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 127

    (39) expression -> FOR expression ; expression ; . expression DO expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 132
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 128

    (55) seq_assign_expression -> dots ID ASSIGN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    }               reduce using rule 55 (seq_assign_expression -> dots ID ASSIGN expression .)
    ;               reduce using rule 55 (seq_assign_expression -> dots ID ASSIGN expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 129

    (44) expression -> ID dots ID ( expression_list ) .

    +               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    -               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    *               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    /               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    AND             reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    EQ              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    =               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    >               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    <               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    GE              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    LE              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    NEQS            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    OR              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    NAND            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    $end            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    }               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ;               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    THEN            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ,               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    LAMBDA          reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    DO              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    )               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ]               reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    IN              reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)
    ELSE            reduce using rule 44 (expression -> ID dots ID ( expression_list ) .)


state 130

    (12) expression -> LOCAL ID ASSIGN expression IN expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for = resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NEQS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NAND resolved as shift
    $end            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    }               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ;               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    THEN            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ,               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    LAMBDA          reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    DO              reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    )               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ]               reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    IN              reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    ELSE            reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! -               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! *               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! /               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! AND             [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! EQ              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! =               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! >               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! <               [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! GE              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! LE              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! NEQS            [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! OR              [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]
  ! NAND            [ reduce using rule 12 (expression -> LOCAL ID ASSIGN expression IN expression .) ]


state 131

    (21) expression -> IF expression THEN expression ELSE expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    }               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ;               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    THEN            reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ,               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    LAMBDA          reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    DO              reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    )               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ]               reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    IN              reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    ELSE            reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! -               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! *               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! /               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! AND             [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! EQ              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! =               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! >               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! <               [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! GE              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! LE              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! NEQS            [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! OR              [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]
  ! NAND            [ reduce using rule 21 (expression -> IF expression THEN expression ELSE expression .) ]


state 132

    (39) expression -> FOR expression ; expression ; expression . DO expression
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    DO              shift and go to state 133
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38


state 133

    (39) expression -> FOR expression ; expression ; expression DO . expression
    (1) expression -> . - expression
    (2) expression -> . expression + expression
    (3) expression -> . expression - expression
    (4) expression -> . expression * expression
    (5) expression -> . expression / expression
    (6) expression -> . STRUCT { sequence_struct }
    (9) expression -> . NUMBER
    (10) expression -> . { sequence }
    (11) expression -> . EXTEND ID { sequence_struct }
    (12) expression -> . LOCAL ID ASSIGN expression IN expression
    (13) expression -> . BOOL
    (14) expression -> . IF expression THEN expression
    (15) expression -> . IMPORT ID AS ID
    (20) expression -> . FLOAT
    (21) expression -> . IF expression THEN expression ELSE expression
    (22) expression -> . IMPORT ID
    (23) expression -> . expression AND expression
    (24) expression -> . expression EQ expression
    (25) expression -> . expression = expression
    (26) expression -> . expression > expression
    (27) expression -> . expression < expression
    (28) expression -> . expression GE expression
    (29) expression -> . expression LE expression
    (30) expression -> . expression NEQS expression
    (31) expression -> . expression OR expression
    (32) expression -> . expression NAND expression
    (33) expression -> . LAMBDA_START LAMBDA expression
    (34) expression -> . LAMBDA_START expression_list LAMBDA expression
    (35) expression -> . STRING
    (36) expression -> . ID dots ID
    (37) expression -> . LOOP expression DO expression
    (38) expression -> . CHAR
    (39) expression -> . FOR expression ; expression ; expression DO expression
    (40) expression -> . ID ( )
    (41) expression -> . ID ( expression_list )
    (42) expression -> . ID
    (43) expression -> . ID dots ID ( )
    (44) expression -> . ID dots ID ( expression_list )
    (45) expression -> . WHILE expression DO expression
    (47) expression -> . [ expression_list ]
    (48) expression -> . dots_in_struct_expression ( )
    (49) expression -> . dots_in_struct_expression ( expression_list )
    (50) expression -> . ID [ NUMBER ]
    (51) expression -> . ( expression_list )
    (52) expression -> . NOT expression
    (53) expression -> . ID ASSIGN expression
    (54) expression -> . dots ID ASSIGN expression
    (46) dots_in_struct_expression -> . dots ID
    (16) dots -> . .
    (17) dots -> . . dots

    -               shift and go to state 2
    STRUCT          shift and go to state 3
    NUMBER          shift and go to state 5
    {               shift and go to state 4
    EXTEND          shift and go to state 6
    LOCAL           shift and go to state 8
    BOOL            shift and go to state 9
    IF              shift and go to state 10
    IMPORT          shift and go to state 11
    FLOAT           shift and go to state 12
    LAMBDA_START    shift and go to state 13
    STRING          shift and go to state 14
    ID              shift and go to state 7
    LOOP            shift and go to state 16
    CHAR            shift and go to state 17
    FOR             shift and go to state 18
    WHILE           shift and go to state 20
    [               shift and go to state 21
    (               shift and go to state 19
    NOT             shift and go to state 23
    .               shift and go to state 24

    expression                     shift and go to state 134
    dots                           shift and go to state 15
    dots_in_struct_expression      shift and go to state 22

state 134

    (39) expression -> FOR expression ; expression ; expression DO expression .
    (2) expression -> expression . + expression
    (3) expression -> expression . - expression
    (4) expression -> expression . * expression
    (5) expression -> expression . / expression
    (23) expression -> expression . AND expression
    (24) expression -> expression . EQ expression
    (25) expression -> expression . = expression
    (26) expression -> expression . > expression
    (27) expression -> expression . < expression
    (28) expression -> expression . GE expression
    (29) expression -> expression . LE expression
    (30) expression -> expression . NEQS expression
    (31) expression -> expression . OR expression
    (32) expression -> expression . NAND expression

    $end            reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    }               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ;               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    THEN            reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ,               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    LAMBDA          reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    DO              reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    )               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ]               reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    IN              reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    ELSE            reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .)
    +               shift and go to state 25
    -               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    AND             shift and go to state 29
    EQ              shift and go to state 30
    =               shift and go to state 31
    >               shift and go to state 32
    <               shift and go to state 33
    GE              shift and go to state 34
    LE              shift and go to state 35
    NEQS            shift and go to state 36
    OR              shift and go to state 37
    NAND            shift and go to state 38

  ! +               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! -               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! *               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! /               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! AND             [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! EQ              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! =               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! >               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! <               [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! GE              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! LE              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! NEQS            [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! OR              [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]
  ! NAND            [ reduce using rule 39 (expression -> FOR expression ; expression ; expression DO expression .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 130 resolved as shift
WARNING: shift/reduce conflict for - in state 130 resolved as shift
WARNING: shift/reduce conflict for * in state 130 resolved as shift
WARNING: shift/reduce conflict for / in state 130 resolved as shift
WARNING: shift/reduce conflict for AND in state 130 resolved as shift
WARNING: shift/reduce conflict for EQ in state 130 resolved as shift
WARNING: shift/reduce conflict for = in state 130 resolved as shift
WARNING: shift/reduce conflict for > in state 130 resolved as shift
WARNING: shift/reduce conflict for < in state 130 resolved as shift
WARNING: shift/reduce conflict for GE in state 130 resolved as shift
WARNING: shift/reduce conflict for LE in state 130 resolved as shift
WARNING: shift/reduce conflict for NEQS in state 130 resolved as shift
WARNING: shift/reduce conflict for OR in state 130 resolved as shift
WARNING: shift/reduce conflict for NAND in state 130 resolved as shift
