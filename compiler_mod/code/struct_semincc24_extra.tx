{
    out:=123;
  s := struct {
    .x := 7;
    .set_x := \x -> .x := x
  };
  t := extend s {
    .x := 5;
  # ..x := 2; #! disallowed
  # .set_px := \x -> ..x := x; #! disallowed
    .set_px := \x -> ..set_x(x);
    .set_x := \x -> .x := x
  };
  print(t.out);
  # exit();
  print(out);
  print(s.out);
  print(t.out);
  print("check ..x");
  print(t.x);
  t.set_x(99);
  print(s.x);
  # t.set_px(2);
  print(t.x); #2
  print(t..x); #7
  t..set_x(1);
  print(t..x); #1
# t.x := 1; #! disallowed
  print(t.x); #2

  f := 3;
  r := struct {
    .g := \ -> f;
    .h := \x -> f := x
  };
  print(r.g()); #3
  r.h(5);
  print(r.g()); #5

  # hinzugefÃ¼gt: assign member of parent not known in child
  u := struct {
    .x := 1
  };
  v := extend u {
    .set_x := \x -> .x := x
  };
  print("herer");
  print(u.x);
v.set_x(5); #!disallowed
  print(u.x); # This is not setting it, but it should give an error message?! 

  # optional:
#   {
#     a := struct {
#       set .x := 1;
# #     .set_x := \x -> .x := x; # generated
#       .y := 2
#     };
#     a.set_x(5); # allowed
# #   a.set_y(2); #! disallowed, set_y not generated
#     print(a.x); #5, allowed
#     print(a.y) #2, allowed
#   }

  print(t..x); #1
  print(t.x)#2
}
