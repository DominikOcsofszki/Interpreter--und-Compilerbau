Funktion kann in vars gespeichert werden.

Funktion => closure, lebt so lange wie die Funktion lebt

--> local fehlt noch

counter := x -> {y -> { x:=y+x;x}};

lambda als ->
eg.
f := { local x:= 1 in
    y -> x+y
    }
f(2) ---> 3
Werte die innerhalb der local definiert sind, such weiter oben ob bereits vorhanden, sonst nei
definiert
============================================================
scopes explizit für while???

lambda als var speichern => function

integration von datentypen

benutzerdefiniert datentype definieren?? wollen wir das?
Wie lambda , oder objektorientierte

records  erstellen?

objektorient => lambda ausdruck der einen anderen lambda ausdruck generiert

(next-week=nw)symboltabellen mitführen? Mit in env übergeben? Alles was bereits existiert? mit annotieren? Alles
neue anders

=====================================

Functions:
expr müsste identifier haben?
```
exp_list = exp
|exp_list comma expression```

muss immer seperate definiert werden, da annahme, dass keine empty(eps) nicht in der Sprache ist,
sonst würden manche dinge nicht funktionieren
p_empty(p):
    'empty :'
    pass

listen kann man auf python listen abbilden
func
exp : exp lparen expre_list rparen
empty func
exp : exp lparen rparen

sollte ähnlich wie lambda anstatt fun
fun identifert lparen exp_list rparen colon expr


Environment kann 'print' : print <-  python-funktion binden

import implementieren: => import => maping to dict


syntax von c für char string
nil, float, string, char


(1,(2,(3,()))

sadly not, can implement both if wanted
f := (x,y) -> expr
f := () -> expr

winner:
f := x,y -> expr
f := -> expr
Tasks:

f() f(x,z,s)

string  ""
char    '' 
float   3.123 (auch .3 und 3.)

list    list(1,2,3)  => all types
- head(l), tail(l)

array   [1,2,3]    (optional arr(1,2,3)) => only same type
- a[i] für i elemnt


